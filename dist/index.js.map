{
  "version": 3,
  "sources": ["../src/core/index.ts", "../src/helper/index.ts", "../src/helper/filter.ts", "../src/helper/parser.ts", "../src/helper/fn.ts", "../src/helper/loader.ts", "../src/helper/tmp.ts", "../src/core/image.ts", "../src/core/core.ts", "../src/core/text.ts", "../src/core/csv.ts", "../src/core/pdf/pdf.ts", "../src/core/pdf/experimental-pdf.ts", "../src/core/av/av.ts", "../src/core/av/audio.ts", "../src/core/av/video.ts", "../src/processor.ts"],
  "sourcesContent": ["export { default as Image } from \"./image.js\";\nexport { default as Text } from \"./text.js\";\nexport { default as CSV } from \"./csv.js\";\nexport * from \"./pdf/index.js\";\nexport * from \"./av/index.js\";\n", "export { default as FilterFile } from \"./filter.js\";\nexport { default as TmpFile } from \"./tmp.js\";\nexport * as loader from \"./loader.js\";\nexport * as parser from \"./parser.js\";\nexport * from \"./fn.js\";\n", "import type { FileTypeResult, MimeType, FileExtension } from \"file-type\";\nimport type { InputFiles } from \"../types/index.js\";\nimport { Mutex } from \"async-mutex\";\nimport isFile, { Node as isFileNode } from \"@ryn-bsd/is-file\";\nimport { toBuffer } from \"./parser.js\";\n\n/**\n * Easy and fast way to filter bunche of files\n */\nexport default class FilterFile {\n  private readonly input: InputFiles[];\n\n  constructor(...input: InputFiles[]) {\n    this.input = input;\n  }\n\n  async application() {\n    const { applications } = await FilterFile.filter(...this.input);\n    return applications;\n  }\n\n  async audio() {\n    const { audios } = await FilterFile.filter(...this.input);\n    return audios;\n  }\n\n  async font() {\n    const { fonts } = await FilterFile.filter(...this.input);\n    return fonts;\n  }\n\n  async image() {\n    const { images } = await FilterFile.filter(...this.input);\n    return images;\n  }\n\n  async model() {\n    const { models } = await FilterFile.filter(...this.input);\n    return models;\n  }\n\n  async text() {\n    const { texts } = await FilterFile.filter(...this.input);\n    return texts;\n  }\n\n  async video() {\n    const { videos } = await FilterFile.filter(...this.input);\n    return videos;\n  }\n\n  /**\n   * Filter custom file\n   * @param me - mime extension\n   */\n  async custom(me: string) {\n    const buffer = await toBuffer(this.input);\n    const result = await isFile.isCustom(buffer, me);\n    return result.filter((file) => file.valid).map((file) => file.value) as Buffer[];\n  }\n\n  static async filter(...input: InputFiles[]) {\n    const buffer = await toBuffer(input);\n\n    const mutexes = {\n      applications: new Mutex(),\n      audios: new Mutex(),\n      fonts: new Mutex(),\n      images: new Mutex(),\n      models: new Mutex(),\n      texts: new Mutex(),\n      videos: new Mutex(),\n    };\n\n    const files: Record<keyof typeof mutexes, Buffer[]> = {\n      applications: [],\n      audios: [],\n      fonts: [],\n      images: [],\n      models: [],\n      texts: [],\n      videos: [],\n    };\n\n    await Promise.all(\n      buffer.map(async (buffer) => {\n        if (await isFile.isApplication(buffer)) {\n          const release = await mutexes.applications.acquire();\n          files.applications.push(buffer);\n          release();\n        } else if (await isFile.isAudio(buffer)) {\n          const release = await mutexes.audios.acquire();\n          files.audios.push(buffer);\n          release();\n        } else if (await isFile.isFont(buffer)) {\n          const release = await mutexes.fonts.acquire();\n          files.fonts.push(buffer);\n          release();\n        } else if (await isFile.isImage(buffer)) {\n          const release = await mutexes.images.acquire();\n          files.images.push(buffer);\n          release();\n        } else if (await isFile.isModel(buffer)) {\n          const release = await mutexes.models.acquire();\n          files.models.push(buffer);\n          release();\n        } else if (await isFile.isText(buffer)) {\n          const release = await mutexes.texts.acquire();\n          files.texts.push(buffer);\n          release();\n        } else if (await isFile.isVideo(buffer)) {\n          const release = await mutexes.videos.acquire();\n          files.videos.push(buffer);\n          release();\n        }\n      }),\n    );\n\n    return files;\n  }\n\n  static async type<T extends InputFiles>(files: T): Promise<FileTypeResult | undefined>;\n  static async type<T extends InputFiles[]>(files: T): Promise<(FileTypeResult | undefined)[]>;\n  static async type<T extends InputFiles | InputFiles[]>(files: T) {\n    if (Array.isArray(files)) return Promise.all(files.map((file) => FilterFile.type(file)));\n    const buffer = await toBuffer(files);\n    return isFileNode.type(buffer);\n  }\n\n  static async mime<T extends InputFiles>(files: T): Promise<MimeType | undefined>;\n  static async mime<T extends InputFiles[]>(files: T): Promise<(MimeType | undefined)[]>;\n  static async mime<T extends InputFiles | InputFiles[]>(files: T) {\n    if (Array.isArray(files)) return Promise.all(files.map((file) => FilterFile.mime(file)));\n    const type = await FilterFile.type(files);\n    return type?.mime;\n  }\n\n  static async extension<T extends InputFiles>(files: T): Promise<FileExtension | undefined>;\n  static async extension<T extends InputFiles[]>(files: T): Promise<(FileExtension | undefined)[]>;\n  static async extension<T extends InputFiles | InputFiles[]>(files: T) {\n    if (Array.isArray(files)) return Promise.all(files.map((file) => FilterFile.extension(file)));\n    const type = await FilterFile.type(files);\n    return type?.ext;\n  }\n}\n", "import { isAnyArrayBuffer, isUint8Array } from \"node:util/types\";\nimport { Readable } from \"node:stream\";\nimport fs from \"node:fs\";\nimport { InputFiles } from \"../types/index.js\";\nimport { isUrl } from \"./fn.js\";\nimport {\n  any2buffer,\n  array2buffer,\n  buffer2readable,\n  isReadable,\n  isReadableStream,\n  isStream,\n  readable2buffer,\n  readablestream2buffer,\n  stream2buffer,\n  string2buffer,\n  uint8array2buffer,\n} from \"@ryn-bsd/from-buffer-to\";\nimport isBase64 from \"is-base64\";\nimport { loadFile, loadUrl } from \"./loader.js\";\n\n/**\n * @param input - any type of supported inputs\n *\n * @example\n * ```js\n *  toBuffer(\"cnluYnNk\")\n *  toBuffer(\"/file.text\")\n *  toBuffer(\"https://example.com/file.text\")\n * ```\n */\nexport async function toBuffer<T extends InputFiles>(input: T): Promise<Buffer>;\nexport async function toBuffer<T extends InputFiles[]>(input: T): Promise<Buffer[]>;\nexport async function toBuffer<T extends InputFiles | InputFiles[]>(input: T) {\n  if (Array.isArray(input)) return Promise.all(input.map((i) => toBuffer(i)));\n\n  if (Buffer.isBuffer(input)) return input;\n  else if (isUrl(input)) return loadUrl(input);\n  else if (isUint8Array(input)) return uint8array2buffer(input);\n  else if (isAnyArrayBuffer(input)) return array2buffer(input);\n  else if (isStream(input)) return stream2buffer(input);\n  else if (isReadableStream(input)) return readablestream2buffer(input);\n  else if (isReadable(input) && Readable.isReadable(input)) return readable2buffer(input);\n  else if (typeof input === \"string\") {\n    const fileStat = await fs.promises.stat(input);\n    if (fileStat.isFile()) return loadFile(input);\n    else if (isBase64(input, { allowEmpty: false })) return Buffer.from(input, \"base64\");\n    return string2buffer(input, false);\n  }\n  return any2buffer(input);\n}\n\n/**\n * Convert any type of inputs to Readable\n *\n * @example\n * ```js\n *  toReadable(\"cnluYnNk\")\n *  toReadable(\"/file.text\")\n *  toReadable(\"https://example.com/file.text\")\n * ```\n */\nexport async function toReadable<T extends InputFiles>(input: T): Promise<Readable>;\nexport async function toReadable<T extends InputFiles[]>(input: T): Promise<Readable[]>;\nexport async function toReadable<T extends InputFiles | InputFiles[]>(input: T) {\n  if (Array.isArray(input)) return Promise.all(input.map((i) => toReadable(i)));\n  if (isReadable(input) && Readable.isReadable(input)) return input;\n  const buffer = await toBuffer(input);\n  return buffer2readable(buffer);\n}\n\n/**\n * Convert any type of inputs into base64 | base64url\n *\n * @example\n * ```js\n *  toBase64(\"cnluYnNk\")\n *  toBase64(\"/file.text\")\n *  toBase64(\"https://example.com/file.text\")\n * ```\n */\nexport async function toBase64<T extends InputFiles>(input: T, encoding?: \"base64\" | \"base64url\"): Promise<string>;\nexport async function toBase64<T extends InputFiles[]>(input: T, encoding?: \"base64\" | \"base64url\"): Promise<string[]>;\nexport async function toBase64<T extends InputFiles | InputFiles[]>(\n  input: T,\n  encoding: \"base64\" | \"base64url\" = \"base64\",\n) {\n  if (Array.isArray(input)) return Promise.all(input.map((i) => toBase64(i)));\n  if (typeof input === \"string\" && isBase64(input)) return input;\n  const buffer = await toBuffer(input);\n  return buffer.toString(encoding);\n}\n\n/**\n * Save any type of inputs into file\n *\n * @example\n * ```js\n *  toFile(\n *    [\n *      {\n *        path: \"where-to-store.txt\",\n *        input: Buffer.alloc(1)\n *      }\n *    ]\n *  )\n * ```\n */\nexport async function toFile(file: { path: string; input: InputFiles }[]) {\n  await Promise.all(\n    file.map(async (f) => {\n      const buffer = await toBuffer(f.input);\n      return fs.promises.writeFile(f.path, buffer);\n    }),\n  );\n}\n", "export function isArrayOfBuffer(array: unknown[]): array is Buffer[] {\n  if (!Array.isArray(array)) return false;\n  for (const arr of array) if (!Buffer.isBuffer(arr)) return false;\n  return true;\n}\n\nexport function isArrayOfString(array: unknown[]): array is string[] {\n  if (!Array.isArray(array)) return false;\n  for (const arr of array) if (typeof arr !== \"string\") return false;\n  return true;\n}\n\nexport function isUrl(value: unknown): value is URL {\n  if (typeof value !== \"string\") return false;\n\n  try {\n    new URL(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n", "import fs from \"node:fs\";\nimport path from \"node:path\";\nimport fastGlob from \"fast-glob\";\nimport { url2buffer } from \"@ryn-bsd/from-buffer-to\";\n\n/**\n *  @param paths - file/files path\n *\n * @example\n * ```js\n *  const files = loadFile([\"/file.txt\", \"/image.png\"])\n *  // => Buffer[]\n *\n *  const file = loadFile(\"/file.txt\")\n *  // => Buffer\n * ```\n */\nexport async function loadFile<T extends string>(paths: T): Promise<Buffer>;\nexport async function loadFile<T extends string[]>(paths: T): Promise<Buffer[]>;\nexport async function loadFile<T extends string | string[]>(paths: T) {\n  if (Array.isArray(paths)) return Promise.all(paths.map((path) => loadFile(path)));\n  return fs.promises.readFile(paths);\n}\n\n/**\n *  @param paths - directory/directories path\n *\n * @example\n * ```js\n *  const files = loadDir([\"/dir1\", \"/dir2\"])\n *  // => Buffer[][]\n *\n *  const file = loadDir(\"/dir\")\n *  // => Buffer[]\n * ```\n */\nexport async function loadDir<T extends string>(paths: T): Promise<Buffer[]>;\nexport async function loadDir<T extends string[]>(paths: T): Promise<Buffer[][]>;\nexport async function loadDir<T extends string | string[]>(paths: T) {\n  if (Array.isArray(paths)) return Promise.all(paths.map((path) => loadDir(path)));\n  const files = await fs.promises.readdir(paths);\n  return loadFile(files.map((file) => path.join(paths, file)));\n}\n\n/**\n * @example\n * ```js\n *  loadGlob(\"/*.txt\")\n *  // => (Buffer | Buffer[])[]\n *\n *  loadGlob([\"/*.txt\", \"/images\"])\n *  // => (Buffer | Buffer[])[]\n * ```\n */\nexport async function loadGlob<T extends fastGlob.Pattern | fastGlob.Pattern[]>(\n  globs: T,\n  options?: fastGlob.Options,\n): Promise<(Buffer | Buffer[])[]> {\n  const cwd = options?.cwd ?? process.cwd();\n\n  const entries = await fastGlob(globs, options);\n  const results = await Promise.all(\n    entries.map(async (entry) => {\n      const fullPath = path.join(cwd, entry);\n      const stat = await fs.promises.stat(fullPath);\n\n      if (stat.isFile()) return loadFile(fullPath);\n      else if (stat.isDirectory()) return loadDir(fullPath);\n      return null;\n    }),\n  );\n\n  return results.filter((result) => result !== null) as (Buffer | Buffer[])[];\n}\n\n/**\n *  @param urls - file/files url\n *\n * @example\n * ```js\n *  const files = loadUrl([\"https://example.com/file.text\", \"https://example.com/image.png\"])\n *  // => Buffer[]\n *\n *  const file = loadUrl(\"https://example.com/file.text\")\n *  // => Buffer\n * ```\n */\nexport async function loadUrl<T extends string | URL>(urls: T): Promise<Buffer>;\nexport async function loadUrl<T extends string[] | URL[]>(urls: T): Promise<Buffer[]>;\nexport async function loadUrl<T extends string | URL | string[] | URL[]>(urls: T) {\n  if (Array.isArray(urls)) return Promise.all(urls.map((url) => loadUrl(url)));\n  return url2buffer(urls);\n}\n", "import type { DirOptions } from \"tmp\";\nimport { writeFile } from \"node:fs/promises\";\nimport { randomUUID } from \"node:crypto\";\nimport path from \"node:path\";\nimport { dir, type DirectoryResult } from \"tmp-promise\";\nimport FilterFile from \"./filter.js\";\n\n/**\n * Create a tmp dir store your files manipulate them and then clean.\n */\nexport default class TmpFile {\n  private readonly files: Buffer[];\n\n  public readonly paths: string[] = [];\n  public tmp?: DirectoryResult;\n\n  constructor(...files: Buffer[]) {\n    this.files = files;\n  }\n\n  private async createFn(file: Buffer) {\n    const ext = (await FilterFile.extension(file)) ?? \"\";\n    if (ext.length === 0) throw new Error(`${TmpFile.name}: Unknown file when create`);\n\n    const fileName = TmpFile.generateFileName(ext);\n    const fullPath = path.join(this.tmp!.path, fileName);\n\n    await writeFile(fullPath, file);\n    this.paths.push(fullPath);\n  }\n\n  private async create() {\n    await Promise.all(this.files.map(this.createFn.bind(this)));\n  }\n\n  async init(options?: DirOptions) {\n    this.tmp = await dir({ unsafeCleanup: true, ...options });\n    await this.create();\n    return this as Omit<TmpFile, \"init\">;\n  }\n\n  async clean() {\n    await this.tmp!.cleanup();\n    this.paths.splice(0, this.paths.length);\n  }\n\n  static generateFileName(ext: string) {\n    return `${randomUUID()}_${Date.now()}.${ext}`;\n  }\n}\n", "import type { ScreenshotOptions } from \"puppeteer\";\nimport type {\n  ImageCustomCallback,\n  ImageFormats,\n  ImageOptions,\n  ImageSetCallback,\n  ImageWatermarkOptions,\n  InputFiles,\n} from \"../types/index.js\";\nimport { FilterFile, loader, parser } from \"../helper/index.js\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport fastGlob from \"fast-glob\";\nimport { createWorker } from \"tesseract.js\";\nimport sharp from \"sharp\";\nimport Core from \"./core.js\";\n\nexport default class Image extends Core {\n  private images: Buffer[];\n\n  /**\n   * Create unsafe instance\n   *\n   * to create safe instance:\n   * ```js\n   *  const imageFile = await Image.loadFile(\"image.png\")\n   *\n   *  // create safe new instance\n   *  const image = Image.new(imageFile)\n   *  // => Image\n   * ```\n   */\n  constructor(...images: Buffer[]) {\n    super();\n    this.images = images;\n  }\n\n  /** get current length of images */\n  get length() {\n    return this.images.length;\n  }\n\n  /**\n   * get images of this instance\n   *\n   * @example\n   * ```js\n   *  const buffer = await Image.loadFile(\"image.png\")\n   *\n   *  // not the same reference\n   *  const images = new Image(buffer).getImages()\n   *  // => Buffer[]\n   * ```\n   */\n  getImages() {\n    return [...this.images];\n  }\n\n  /**\n   * set images\n   *\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const image = await Image.fromFile(\"image.png\")\n   *\n   *  // this method filter invalid images before set\n   *  const newLength = await image.setImages(\\* async *\\(image, index) => {\n   *    return index % 2 ? image : image.toString()\n   *  })\n   *  // => 0\n   * ```\n   */\n  async setImages<T>(callback: ImageSetCallback<T>) {\n    const images = await Promise.all(this.images.map(async (image, index) => callback(image, index)));\n    const filteredImages = images.filter((image) => Buffer.isBuffer(image) && image.length > 0) as Buffer[];\n    const validImages = await Image.filter(...filteredImages);\n    this.images = validImages;\n    return this.length;\n  }\n\n  /**\n   *\n   * @param images - new images (Buffer) to append the exists list\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const image = new Image()\n   *  const buffer1 = await Image.loadFile(\"image1.png\")\n   *  const buffer2 = await Image.loadFile(\"image2.png\")\n   *\n   *  // filter invalid images\n   *  await image.append(buffer1, Buffer.alloc(1), buffer2)\n   *  // => 2\n   * ```\n   */\n  override async append(...images: Buffer[]) {\n    const filteredImages = await Image.filter(...images);\n    this.images.push(...filteredImages);\n    return this.length;\n  }\n\n  /**\n   *\n   * @param images - extend images from instance to an another\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const buffer1 = await Image.loadFile(\"image1.png\")\n   *  const buffer2 = await Image.loadFile(\"image2.png\")\n   *  const image1 = new Image(buffer1, buffer2)\n   *\n   *  const image2 = new Image()\n   *\n   *  // don't apply any filters\n   *  image2.extend(image1)\n   *  // => 2\n   * ```\n   */\n  override extend(...images: Image[]) {\n    images.forEach((image) => {\n      this.images.push(...image.getImages());\n    });\n    return this.length;\n  }\n\n  /**\n   *\n   * @returns - clone current instance\n   *\n   * @example\n   * ```js\n   *  const image = new Image()\n   *\n   *  // not the same reference\n   *  const clone = image.clone()\n   *  // => Image\n   * ```\n   */\n  override clone() {\n    return new Image(...this.images);\n  }\n\n  /**\n   * Clean images array, to free memory\n   *\n   * @example\n   * ```js\n   *  const image = await Image.fromFile(\"image1.png\", \"image2.webp\")\n   *\n   *  // Some operations\n   *\n   *  image.clean()\n   *\n   *  // Some operations\n   *\n   *  image.append(Buffer.alloc(1))\n   * ```\n   */\n  override clean() {\n    this.images = [];\n  }\n\n  /**\n   * filter images\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const image = new Image(Buffer.alloc(1))\n   *  await image.filter()\n   *  // => 0\n   * ```\n   */\n  override async filter() {\n    this.images = await Image.filter(...this.images);\n    return this.length;\n  }\n\n  /**\n   * @returns - images metadata\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const image = new Image(image1, image2)\n   *  const metadata = await image.metadata()\n   *  // => Metadata[]\n   * ```\n   */\n  override async metadata() {\n    return this.custom((sharp) => sharp.metadata());\n  }\n\n  /**\n   * Add watermark to images\n   *\n   * const logo = \"logo.png\" // or any supported input type\n   *\n   * const image1 = await Image.loadFile(\"image1.png\")\n   * const image2 = await Image.loadFile(\"image2.png\")\n   * const image = new Image(image1, image2)\n   *\n   * const watermark = await image.watermark(logo)\n   * // => { data: Buffer; info: sharp.OutputInfo; }[]\n   */\n  async watermark(logo: InputFiles, options: ImageWatermarkOptions = {}) {\n    const { resize, gravity = \"center\", alpha = 0.5, tile = false, blend = \"over\", premultiplied } = options;\n\n    const buffer = await parser.toBuffer(logo);\n    const input = await Image.newSharp(buffer)\n      .resize(resize)\n      .ensureAlpha(alpha)\n      .composite([\n        {\n          input: Buffer.from([0, 0, 0, Math.round(255 * alpha)]),\n          raw: {\n            width: 1,\n            height: 1,\n            channels: 4,\n          },\n          tile: true,\n          blend: \"dest-in\",\n        },\n      ])\n      .toBuffer();\n\n    return this.custom((sharp) => {\n      return sharp.composite([{ input, gravity, blend, tile, premultiplied }]).toBuffer({ resolveWithObject: true });\n    });\n  }\n\n  /**\n   * @returns converted images\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const image = new Image(image1, image2)\n   *  const buffers = await image.convert(\"webp\")\n   *  // => { data: Buffer; info: sharp.OutputInfo; }[]\n   * ```\n   */\n  async convert<F extends ImageFormats>(format: F, options?: ImageOptions<F>) {\n    return this.custom((sharp) => {\n      return sharp.toFormat(format, options).toBuffer({\n        resolveWithObject: true,\n      });\n    });\n  }\n\n  /**\n   * supported images format @link https://github.com/naptha/tesseract.js/blob/master/docs/image-format.md\n   *\n   * @param langs - languages @link https://github.com/naptha/tesseract.js/blob/master/src/constants/languages.js\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const image = new Image(image1, image2)\n   *  const ocrs = await image.ocr([\"ara\", \"eng\"])\n   *  // => Tesseract.Page[]\n   * ```\n   */\n  async ocr(langs: string | string[]) {\n    const worker = await createWorker(langs);\n    const recs = await Promise.all(this.images.map((image) => worker.recognize(image)));\n    await worker.terminate();\n\n    if (process.env.NODE_ENV === \"development\" || process.env.NODE_ENV === \"test\") {\n      const cwd = process.cwd();\n      const traineddata = await fastGlob(\"*.traineddata\", { cwd });\n      await Promise.all(traineddata.map((data) => fs.promises.unlink(path.join(cwd, data))));\n    }\n\n    return recs.map((rec) => rec.data);\n  }\n\n  /**\n   * @returns base on the callback return type\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const image = new Image(image1, image2)\n   *\n   *  await image.custom(\\* async *\\(sharp, _index) => {\n   *    return sharp.resize({ width: 1280, height: 720, fit: \"fill\" }).blur().toBuffer()\n   *  })\n   *  // => Buffer[]\n   *\n   *  await image.custom(\\* async *\\(_sharp, index) => {\n   *    return index\n   *  })\n   *  // => number[]\n   * ```\n   */\n  async custom<T>(callback: ImageCustomCallback<T>): Promise<Awaited<T>[]> {\n    return Promise.all(this.images.map(async (image, index) => callback(Image.newSharp(image), index)));\n  }\n\n  /**\n   *\n   * @returns - filter non image\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const buffer = await Image.filter(image1, image2)\n   *  // => Buffer[]\n   * ```\n   */\n  static async filter(...images: Buffer[]) {\n    return new FilterFile(...images).image();\n  }\n\n  /**\n   *\n   * @returns - Extract buffer from return methods\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const image = new Image(image1, image2)\n   *  const converted = await image.convert(\"webp\")\n   *  // => { data: Buffer; info: sharp.OutputInfo; }[]\n   *\n   *  const buffers = Image.justBuffer(converted)\n   *  // => Buffer[]\n   * ```\n   * */\n  static justBuffer(rtn: { data: Buffer; info: sharp.OutputInfo }): Buffer;\n  static justBuffer(\n    rtn: {\n      data: Buffer;\n      info: sharp.OutputInfo;\n    }[],\n  ): Buffer[];\n  static justBuffer(\n    rtn:\n      | {\n          data: Buffer;\n          info: sharp.OutputInfo;\n        }[]\n      | {\n          data: Buffer;\n          info: sharp.OutputInfo;\n        },\n  ) {\n    if (Array.isArray(rtn)) return rtn.map((r) => Image.justBuffer(r));\n    return rtn.data;\n  }\n\n  /**\n   * @deprecated\n   * @returns - Take screenshot of websites\n   *\n   * @example\n   * ```js\n   *  const image = awaitImage.screenshot(\"https://example.com\")\n   *  // Buffer\n   *\n   *  const images = awaitImage.screenshot([\"https://example.com\", \"https://example.net\"])\n   *  // Buffer[]\n   * ```\n   * */\n  static async screenshot<T extends string>(urls: T, options?: Omit<ScreenshotOptions, \"encoding\">): Promise<Buffer>;\n  static async screenshot<T extends string[]>(\n    urls: T,\n    options?: Omit<ScreenshotOptions, \"encoding\">,\n  ): Promise<Buffer[]>;\n  static async screenshot<T extends string | string[]>(urls: T, options?: ScreenshotOptions) {\n    if (Array.isArray(urls)) return Promise.all(urls.map(async (url) => Image.screenshot(url, options)));\n\n    const browser = await Core.initBrowser();\n    const page = await browser.newPage();\n\n    const res = await page.goto(urls, { waitUntil: \"networkidle2\" });\n    if (res === null || !res.ok()) throw new Error(`${Image.name}: Can't fetch (${urls})`);\n\n    const buffer = await page.screenshot(options);\n    await browser.close();\n    return buffer;\n  }\n\n  /**\n   * @throws\n   *\n   * load images from files\n   * @returns - loaded files\n   *\n   * @example\n   * ```js\n   *  const image = await Image.fromFile(\"image.png\")\n   *  // => Image\n   *\n   *  const image = await Image.fromFile(\"image.png\", \"text.txt\")\n   *  // => Image\n   *  const length = image.length\n   *  // => 1\n   *\n   *  const text = await Image.fromFile(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromFile(...path: string[]) {\n    const buffer = await loader.loadFile(path);\n    return Image.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * load images from urls\n   * @returns - loaded urls\n   *\n   * @example\n   * ```js\n   *  const image = await Image.fromUrl(\"http://example.com/image.png\")\n   *  // => Image\n   *\n   *  const image = await Image.fromUrl(\"http://example.com/image.png\", \"http://example.com/text.txt\")\n   *  // => Image\n   *  const length = image.length\n   *  // => 1\n   *\n   *  const text = await Image.fromUrl(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await loader.loadUrl(url);\n    return Image.new(buffer);\n  }\n\n  /**\n   * @returns - new instance of sharp\n   *\n   * @example\n   * ```js\n   *  const sharp = Image.newSharp(\"image.png\")\n   *  // => Sharp\n   * ```\n   */\n  static newSharp<T extends Buffer | string | undefined = undefined>(image?: T, options?: sharp.SharpOptions) {\n    return sharp(image, options).clone();\n  }\n\n  /**\n   * @throws\n   *\n   * @param images - images buffer\n   * @returns - create new safe instance\n   *\n   * @example\n   * ```js\n   *  const image = await Image.new(Buffer.alloc(1))\n   *  // => Error (throw)\n   *\n   *  const imageFile = await Image.loadFile(\"image.png\")\n   *\n   *  // filter non image\n   *  const image = await Image.new(imageFile, Buffer.alloc(1))\n   *  // => Image\n   *  const length = image.length\n   *  // => 1\n   * ```\n   */\n  static async new(images: Buffer[]) {\n    const filtered = await Image.filter(...images);\n    if (filtered.length === 0) throw new Error(`${Image.name}: Non valid image`);\n    return new Image(...filtered);\n  }\n\n  /**\n   * check if an object is instance of Image or not\n   * @returns - boolean\n   *\n   * @example\n   * ```js\n   *  const image = new Image()\n   *  const isImage = Image.isImage(image)\n   *  // => true\n   *\n   *  const object = new Object()\n   *  const isNotImage = Image.isImage(object)\n   *  // => false\n   * ```\n   */\n  static isImage(obj: unknown): obj is Image {\n    return obj instanceof Image;\n  }\n}\n", "import type { InputFiles } from \"../types/index.js\";\nimport { Readable, type Writable } from \"node:stream\";\nimport { isAnyArrayBuffer, isUint8Array } from \"node:util/types\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport {\n  any2buffer,\n  array2buffer,\n  buffer2readable,\n  isReadable,\n  isReadableStream,\n  isStream,\n  readable2buffer,\n  readablestream2buffer,\n  stream2buffer,\n  string2buffer,\n  uint8array2buffer,\n  url2buffer,\n} from \"@ryn-bsd/from-buffer-to\";\nimport isBase64 from \"is-base64\";\nimport fastGlob from \"fast-glob\";\nimport puppeteer from \"puppeteer\";\nimport { isUrl } from \"../helper/index.js\";\n\nexport default abstract class Core {\n  constructor() {}\n\n  abstract get length(): number;\n\n  abstract append(...buffers: Buffer[]): Promise<number>;\n  abstract extend(...cors: unknown[]): number;\n  abstract clone(): Core;\n  abstract clean(): void;\n\n  abstract filter(): Promise<number>;\n  abstract metadata(): Promise<unknown>;\n\n  // abstract stream(): Promise<void>;\n\n  /**\n   * @param readable - input\n   * @param writable - output or middleware\n   *\n   * @example\n   * ```js\n   *  const writable = Core.stream(readable, transform)\n   *  // => Writable\n   *\n   *  writable.pipe(output)\n   * ```\n   */\n  static stream(readable: Readable, writable: Writable) {\n    return readable.pipe(writable);\n  }\n\n  static initBrowser(options?: puppeteer.PuppeteerLaunchOptions) {\n    return puppeteer.launch(options);\n  }\n\n  /**\n   * @deprecated use loader.loadFile() from helper\n   *\n   * @param paths - file/files path\n   *\n   * @example\n   * ```js\n   *  const files = Core.loadFile([\"/file.txt\", \"/image.png\"])\n   *  // => Buffer[]\n   *\n   *  const file = Core.loadFile(\"/file.txt\")\n   *  // => Buffer\n   * ```\n   */\n  static async loadFile<T extends string>(paths: T): Promise<Buffer>;\n  static async loadFile<T extends string[]>(paths: T): Promise<Buffer[]>;\n  static async loadFile<T extends string | string[]>(paths: T) {\n    if (Array.isArray(paths)) return Promise.all(paths.map((path) => Core.loadFile(path)));\n    return fs.promises.readFile(paths);\n  }\n\n  /**\n   * @deprecated use loader.loadDir() from helper\n   *\n   * @param paths - directory/directories path\n   *\n   * @example\n   * ```js\n   *  const files = Core.loadDir([\"/dir1\", \"/dir2\"])\n   *  // => Buffer[][]\n   *\n   *  const file = Core.loadDir(\"/dir\")\n   *  // => Buffer[]\n   * ```\n   */\n  static async loadDir<T extends string>(paths: T): Promise<Buffer[]>;\n  static async loadDir<T extends string[]>(paths: T): Promise<Buffer[][]>;\n  static async loadDir<T extends string | string[]>(paths: T) {\n    if (Array.isArray(paths)) return Promise.all(paths.map((path) => Core.loadDir(path)));\n    const files = await fs.promises.readdir(paths);\n    return Core.loadFile(files.map((file) => path.join(paths, file)));\n  }\n\n  /**\n   * @deprecated  use loader.loadGlob() from helper\n   *\n   * @example\n   * ```js\n   *  Core.loadGlob(\"/*.txt\")\n   *  // => (Buffer | Buffer[])[]\n   *\n   *  Core.loadGlob([\"/*.txt\", \"/images\"])\n   *  // => (Buffer | Buffer[])[]\n   * ```\n   */\n  static async loadGlob<T extends fastGlob.Pattern | fastGlob.Pattern[]>(\n    globs: T,\n    options?: fastGlob.Options,\n  ): Promise<(Buffer | Buffer[])[]> {\n    const entries = await fastGlob(globs, options);\n    const cwd = options?.cwd ?? process.cwd();\n\n    const results = await Promise.all(\n      entries.map(async (entry) => {\n        const fullPath = path.join(cwd, entry);\n        const stat = await fs.promises.stat(fullPath);\n\n        if (stat.isFile()) return Core.loadFile(fullPath);\n        else if (stat.isDirectory()) return Core.loadDir(fullPath);\n        return null;\n      }),\n    );\n\n    return results.filter((result) => result !== null) as (Buffer | Buffer[])[];\n  }\n\n  /**\n   * @deprecated  use loader.loadUrl() from helper\n   *\n   *  @param urls - file/files url\n   *\n   * @example\n   * ```js\n   *  const files = Core.loadUrl([\"https://example.com/file.text\", \"https://example.com/image.png\"])\n   *  // => Buffer[]\n   *\n   *  const file = Core.loadUrl(\"https://example.com/file.text\")\n   *  // => Buffer\n   * ```\n   */\n  static async loadUrl<T extends string | URL>(urls: T): Promise<Buffer>;\n  static async loadUrl<T extends string[] | URL[]>(urls: T): Promise<Buffer[]>;\n  static async loadUrl<T extends string | URL | string[] | URL[]>(urls: T) {\n    if (Array.isArray(urls)) return Promise.all(urls.map((url) => Core.loadUrl(url)));\n    return url2buffer(urls);\n  }\n\n  /**\n   * @deprecated use parser.toBuffer() from helper\n   *\n   * @param input - any type of supported inputs\n   *\n   * @example\n   * ```js\n   *  Core.toBuffer(\"cnluYnNk\")\n   *  Core.toBuffer(\"/file.text\")\n   *  Core.toBuffer(\"https://example.com/file.text\")\n   * ```\n   */\n  static async toBuffer<T extends InputFiles>(input: T): Promise<Buffer>;\n  static async toBuffer<T extends InputFiles[]>(input: T): Promise<Buffer[]>;\n  static async toBuffer<T extends InputFiles | InputFiles[]>(input: T) {\n    if (Array.isArray(input)) return Promise.all(input.map((i) => Core.toBuffer(i)));\n\n    if (Buffer.isBuffer(input)) return input;\n    else if (isUrl(input)) return Core.loadUrl(input);\n    else if (isUint8Array(input)) return uint8array2buffer(input);\n    else if (isAnyArrayBuffer(input)) return array2buffer(input);\n    else if (isStream(input)) return stream2buffer(input);\n    else if (isReadableStream(input)) return readablestream2buffer(input);\n    else if (isReadable(input) && Readable.isReadable(input)) return readable2buffer(input);\n    else if (typeof input === \"string\") {\n      const fileStat = await fs.promises.stat(input);\n      if (fileStat.isFile()) return Core.loadFile(input);\n      else if (isBase64(input, { allowEmpty: false })) return Buffer.from(input, \"base64\");\n      return string2buffer(input, false);\n    }\n    return any2buffer(input);\n  }\n\n  /**\n   * @deprecated use parser.toReadable() from helper\n   *\n   * Convert any type of inputs to Readable\n   *\n   * @example\n   * ```js\n   *  Core.toReadable(\"cnluYnNk\")\n   *  Core.toReadable(\"/file.text\")\n   *  Core.toReadable(\"https://example.com/file.text\")\n   * ```\n   */\n  static async toReadable<T extends InputFiles>(input: T): Promise<Readable>;\n  static async toReadable<T extends InputFiles[]>(input: T): Promise<Readable[]>;\n  static async toReadable<T extends InputFiles | InputFiles[]>(input: T) {\n    if (Array.isArray(input)) return Promise.all(input.map((i) => Core.toReadable(i)));\n    if (isReadable(input) && Readable.isReadable(input)) return input;\n    const buffer = await Core.toBuffer(input);\n    return buffer2readable(buffer);\n  }\n\n  /**\n   * @deprecated use parser.toBase64() from helper\n   *\n   * Convert any type of inputs into base64 | base64url\n   *\n   * @example\n   * ```js\n   *  Core.toBase64(\"cnluYnNk\")\n   *  Core.toBase64(\"/file.text\")\n   *  Core.toBase64(\"https://example.com/file.text\")\n   * ```\n   */\n  static async toBase64<T extends InputFiles>(input: T, encoding?: \"base64\" | \"base64url\"): Promise<string>;\n  static async toBase64<T extends InputFiles[]>(input: T, encoding?: \"base64\" | \"base64url\"): Promise<string[]>;\n  static async toBase64<T extends InputFiles | InputFiles[]>(input: T, encoding: \"base64\" | \"base64url\" = \"base64\") {\n    if (Array.isArray(input)) return Promise.all(input.map((i) => Core.toBase64(i)));\n    if (typeof input === \"string\" && isBase64(input)) return input;\n    const buffer = await Core.toBuffer(input);\n    return buffer.toString(encoding);\n  }\n\n  /**\n   * @deprecated use parser.toFile() from helper\n   *\n   * Save any type of inputs into file\n   *\n   * @example\n   * ```js\n   *  Core.toFile(\n   *    [\n   *      {\n   *        path: \"where-to-store.txt\",\n   *        input: Buffer.alloc(1)\n   *      }\n   *    ]\n   *  )\n   * ```\n   */\n  static async toFile(file: { path: string; input: InputFiles }[]) {\n    await Promise.all(\n      file.map(async (f) => {\n        const buffer = await Core.toBuffer(f.input);\n        return fs.promises.writeFile(f.path, buffer);\n      }),\n    );\n  }\n}\n", "import type { Readable } from \"node:stream\";\nimport type {\n  BrotliCompressOptions,\n  BrotliDecompressOptions,\n  CipherOptions,\n  DecipherOptions,\n  DeflateOptions,\n  DeflateRawOptions,\n  GunzipOptions,\n  GzipOptions,\n  HashOptions,\n  HmacOptions,\n  InflateOptions,\n  InflateRawOptions,\n  TextCompressFn,\n  TextCompressionMethods,\n  TextCompressionOptions,\n  TextCustomCallback,\n  TextDecompressFn,\n  TextDecompressionMethods,\n  TextDecompressionOptions,\n  TextSetCallback,\n  UnzipOptions,\n} from \"../types/index.js\";\nimport zlib from \"node:zlib\";\nimport crypto from \"node:crypto\";\nimport { FilterFile, loader, parser } from \"../helper/index.js\";\nimport Core from \"./core.js\";\n\n/**\n * At the end all files are just texts, so this class is applicable on all files\n */\nexport default class Text extends Core {\n  private texts: Buffer[];\n\n  /**\n   * Create unsafe instance\n   *\n   * to create safe instance:\n   * ```js\n   *  const textFile = await Text.loadFile(\"text.txt\")\n   *\n   *  // create safe new instance\n   *  const text = Text.new(textFile)\n   *  // => Text\n   * ```\n   */\n  constructor(...texts: Buffer[]) {\n    super();\n    this.texts = texts;\n  }\n\n  /** get current length of texts */\n  get length() {\n    return this.texts.length;\n  }\n\n  /** get supported hashes from crypto module */\n  get supportedHashes() {\n    return crypto.getHashes();\n  }\n\n  /** get supported ciphers from crypto module */\n  get supportedCiphers() {\n    return crypto.getCiphers();\n  }\n\n  /**\n   * get texts of this instance\n   *\n   * @example\n   * ```js\n   *  const buffer = await Text.loadFile(\"text.txt\")\n   *\n   *  // not the same reference\n   *  const texts = new Text(buffer).getTexts()\n   *  // => Buffer[]\n   * ```\n   */\n  getTexts() {\n    return [...this.texts];\n  }\n\n  /**\n   * set texts\n   *\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"text.txt\")\n   *\n   *  // this method filter invalid texts before set\n   *  const newLength = await text.setTexts(\\* async *\\(text, index) => {\n   *    return index % 2 ? text : text.toString()\n   *  })\n   *  // => 0\n   * ```\n   */\n  async setTexts<T>(callback: TextSetCallback<T>) {\n    const texts = await Promise.all(this.texts.map(async (text, index) => callback(text, index)));\n    const filteredTexts = texts.filter((text) => Buffer.isBuffer(text) && text.length > 0) as Buffer[];\n    this.texts = filteredTexts;\n    return this.length;\n  }\n\n  /**\n   *\n   * @param texts - new texts (Buffer) to append the exists list\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const text = new Text()\n   *  const buffer1 = await Text.loadFile(\"text1.txt\")\n   *  const buffer2 = await Text.loadFile(\"text2.txt\")\n   *\n   *  // filter invalid texts\n   *  await text.append(buffer1, Buffer.alloc(0), buffer2)\n   *  // => 2\n   * ```\n   */\n  override async append(...texts: Buffer[]) {\n    // const filteredTexts = await Text.filter(...texts);\n    const filteredTexts = texts.filter((text) => Buffer.isBuffer(text) && text.length > 0) as Buffer[];\n    this.texts.push(...filteredTexts);\n    return this.length;\n  }\n\n  /**\n   *\n   * @param texts - extend texts from instance to an another\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const buffer1 = await Text.loadFile(\"text1.txt\")\n   *  const buffer2 = await Text.loadFile(\"text2.txt\")\n   *  const text1 = new Text(buffer1, buffer2)\n   *\n   *  const text2 = new Text()\n   *\n   *  // don't apply any filters\n   *  text2.extend(text1)\n   *  // => 2\n   * ```\n   */\n  override extend(...texts: Text[]) {\n    texts.forEach((text) => {\n      this.texts.push(...text.getTexts());\n    });\n    return this.length;\n  }\n\n  /**\n   *\n   * @returns - clone current instance\n   *\n   * @example\n   * ```js\n   *  const text = new Text()\n   *\n   *  // not the same reference\n   *  const clone = text.clone()\n   *  // => Text\n   * ```\n   */\n  override clone() {\n    return new Text(...this.texts);\n  }\n\n  /**\n   * Clean texts array, to free memory\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"text.txt\", \"image.webp\")\n   *\n   *  // Some operations\n   *\n   *  text.clean()\n   *\n   *  // Some operations\n   *\n   *  text.append(Buffer.alloc(1))\n   * ```\n   */\n  override clean() {\n    this.texts = [];\n  }\n\n  /**\n   * filter texts\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const text = new Text(Buffer.alloc(1))\n   *  await text.filter()\n   *  // => 0\n   * ```\n   */\n  override async filter() {\n    this.texts = await Text.filter(...this.texts);\n    return this.length;\n  }\n\n  /**\n   * @returns - key is the character code and value is the count\n   */\n  private charactersMap(text: Buffer) {\n    const map = new Map<number, number>();\n    const string = text.toString();\n\n    for (const str of string) {\n      const code = str.charCodeAt(0);\n      map.has(code) ? map.set(code, map.get(code)! + 1) : map.set(code, 1);\n    }\n\n    return map;\n  }\n\n  /**\n   * @returns - texts metadata\n   *\n   * @example\n   * ```js\n   *  const text1 = await Text.loadFile(\"text1.txt\")\n   *  const text2 = await Text.loadFile(\"text2.txt\")\n   *\n   *  const text = new Text(text1, text2)\n   *  const metadata = await text.metadata()\n   *  // => { size: number; charactersMap: Map<number, number>; }[]\n   * ```\n   */\n  override async metadata() {\n    return this.custom((text) => {\n      return {\n        size: text.length,\n        charactersMap: this.charactersMap(text),\n      };\n    });\n  }\n\n  /**\n   *\n   * @param method - compress method\n   * @param options - compress options\n   * @returns - compressed data\n   *\n   * @example\n   * ```js\n   *  const textFile = await Text.loadFile(\"text.txt\")\n   *  const text = new Text(textFile)\n   *  const buffers = await text.compressAsync(\"gzip\")\n   *  // => Buffer[]\n   * ```\n   */\n  async compressAsync<T extends TextCompressionMethods>(method: T, options?: TextCompressionOptions<T>) {\n    return Promise.all(\n      Text.compress(\n        this.texts,\n        method,\n        Text.gzipAsync,\n        Text.deflateAsync,\n        Text.deflateRawAsync,\n        Text.brotliCompressAsync,\n        options,\n      ),\n    );\n  }\n\n  /**\n   *\n   * @param method - decompress method\n   * @param options - decompress options\n   * @returns - decompressed data\n   *\n   * @example\n   * ```js\n   *  const textFile = await Text.loadFile(\"text.txt.gz\")\n   *  const text = new Text(textFile)\n   *  const buffers = await text.decompressAsync(\"gunzip\")\n   *  // => Buffer[]\n   * ```\n   */\n  async decompressAsync<T extends TextDecompressionMethods>(method: T, options?: TextDecompressionOptions<T>) {\n    return Promise.all(\n      Text.decompress(\n        this.texts,\n        method,\n        Text.gunzipAsync,\n        Text.inflateAsync,\n        Text.inflateRawAsync,\n        Text.brotliDecompressAsync,\n        Text.unzipAsync,\n        options,\n      ),\n    );\n  }\n\n  /**\n   *\n   * @param method - compress method\n   * @param options - compress options\n   * @returns - compressed data\n   *\n   * @example\n   * ```js\n   *  const textFile = await Text.loadFile(\"text.txt\")\n   *  const text = new Text(textFile)\n   *  const buffers = text.compressStream(\"gzip\")\n   *  // => Writable[]\n   * ```\n   */\n  async compressStream<T extends TextCompressionMethods>(method: T, options?: TextCompressionOptions<T>) {\n    const reads = await parser.toReadable(this.texts);\n    return Text.compress(\n      reads,\n      method,\n      Text.gzipStream,\n      Text.deflateStream,\n      Text.deflateRawStream,\n      Text.brotliCompressStream,\n      options,\n    );\n  }\n\n  /**\n   *\n   * @param method - decompress method\n   * @param options - decompress options\n   * @returns - decompressed data\n   *\n   * @example\n   * ```js\n   *  const textFile = await Text.loadFile(\"text.txt.gz\")\n   *  const text = new Text(textFile)\n   *  const buffers = text.decompressStream(\"gunzip\")\n   *  // => Writable[]\n   * ```\n   */\n  async decompressStream<T extends TextDecompressionMethods>(method: T, options?: TextDecompressionOptions<T>) {\n    const reads = await parser.toReadable(this.texts);\n    return Text.decompress(\n      reads,\n      method,\n      Text.gunzipStream,\n      Text.inflateStream,\n      Text.inflateRawStream,\n      Text.brotliDecompressStream,\n      Text.unzipStream,\n      options,\n    );\n  }\n\n  /**\n   *\n   * @param method - compress method\n   * @param options - compress options\n   * @returns - compressed data\n   *\n   * @example\n   * ```js\n   *  const textFile = await Text.loadFile(\"text.txt\")\n   *  const text = new Text(textFile)\n   *  const buffers = text.compressSync(\"gzip\")\n   *  // => Buffer[]\n   * ```\n   */\n  compressSync<T extends TextCompressionMethods>(method: T, options?: TextCompressionOptions<T>) {\n    return Text.compress(\n      this.texts,\n      method,\n      Text.gzipSync,\n      Text.deflateSync,\n      Text.deflateRawSync,\n      Text.brotliCompressSync,\n      options,\n    );\n  }\n\n  /**\n   *\n   * @param method - decompress method\n   * @param options - decompress options\n   * @returns - decompressed data\n   *\n   * @example\n   * ```js\n   *  const textFile = await Text.loadFile(\"text.txt.gz\")\n   *  const text = new Text(textFile)\n   *  const buffers = text.decompressSync(\"gunzip\")\n   *  // => Buffer[]\n   * ```\n   */\n  decompressSync<T extends TextDecompressionMethods>(method: T, options?: TextDecompressionOptions<T>) {\n    return Text.decompress(\n      this.texts,\n      method,\n      Text.gunzipSync,\n      Text.inflateSync,\n      Text.inflateRawSync,\n      Text.brotliDecompressSync,\n      Text.unzipSync,\n      options,\n    );\n  }\n\n  /**\n   *\n   * @param algorithm - hash algorithm\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"text.txt\")\n   *  text.isHashSupported(\"sha256\") // => true\n   *  text.isHashSupported(\"\") // => false\n   * ```\n   */\n  isHashSupported(algorithm: string) {\n    return this.supportedHashes.includes(algorithm);\n  }\n\n  /**\n   *\n   * @param algorithm - hash algorithm\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"text.txt\")\n   *  const hashes = await text.hash(\"sha256\")\n   *  // => Buffer[]\n   * ```\n   */\n  async hash(algorithm: string, options?: HashOptions) {\n    return this.custom((text) => {\n      return crypto.createHash(algorithm, options).update(text).digest();\n    });\n  }\n\n  /**\n   *\n   * @param algorithm - hash algorithm\n   * @param key - secret key to hash\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"text.txt\")\n   *  const hashes = await text.hmac(\"sha256\", Buffer.from(\"secret\"))\n   *  // => Buffer[]\n   * ```\n   */\n  async hmac(algorithm: string, key?: undefined, options?: HmacOptions): Promise<{ key: Buffer; hash: Buffer }[]>;\n  async hmac(algorithm: string, key?: Buffer, options?: HmacOptions): Promise<Buffer[]>;\n  async hmac(algorithm: string, key?: Buffer, options?: HmacOptions) {\n    return this.custom((text) => {\n      switch (Buffer.isBuffer(key)) {\n        case true:\n          return crypto.createHmac(algorithm, key!, options).update(text).digest();\n        default: {\n          const hmacKey = crypto.randomBytes(32);\n          return {\n            key: hmacKey,\n            hash: crypto.createHmac(algorithm, hmacKey, options).update(text).digest(),\n          };\n        }\n      }\n    });\n  }\n\n  /**\n   *\n   * @param algorithm - cipher algorithm\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"text.txt\")\n   *  text.isCipherSupported(\"aes-256-cbc\") // => true\n   *  text.isCipherSupported(\"\") // => false\n   * ```\n   */\n  isCipherSupported(algorithm: string) {\n    return this.supportedCiphers.includes(algorithm);\n  }\n\n  /**\n   *\n   * @param algorithm - cipher algorithm\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"text.txt\")\n   *  const ciphers = await text.cipher(\"aes-256-cbc\", Buffer.alloc(0))\n   *  // => Buffer[]\n   * ```\n   */\n  async cipher(algorithm: string, key: Buffer, iv: Buffer | null = null, options: CipherOptions = {}) {\n    return this.custom((text) => {\n      const cipher = crypto.createCipheriv(algorithm, key, iv, options);\n      return Buffer.concat([cipher.update(text), cipher.final()]);\n    });\n  }\n\n  /**\n   *\n   * @param algorithm - decipher algorithm\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"text.txt\")\n   *  text.isDecipherSupported(\"aes-256-cbc\") // => true\n   *  text.isDecipherSupported(\"\") // => false\n   * ```\n   */\n  isDecipherSupported(algorithm: string) {\n    return this.isCipherSupported(algorithm);\n  }\n\n  /**\n   *\n   * @param algorithm - decipher algorithm\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"text.txt\")\n   *  const deciphers = await text.decipher(\"aes-256-cbc\", Buffer.alloc(0))\n   *  // => Buffer[]\n   * ```\n   */\n  async decipher(algorithm: string, key: Buffer, iv: Buffer | null = null, options: DecipherOptions = {}) {\n    return this.custom((text) => {\n      const decipher = crypto.createDecipheriv(algorithm, key, iv, options);\n      return Buffer.concat([decipher.update(text), decipher.final()]);\n    });\n  }\n\n  /**\n   * @returns - base on the callback return type\n   *\n   * @example\n   * ```js\n   *  const text1 = await Text.loadFile(\"text1.txt\")\n   *  const text2 = await Text.loadFile(\"text2.txt\")\n   *\n   *  const text = new Text(text1, text2)\n   *\n   *  await text.custom(\\* async *\\(text, _index) => {\n   *    return text.toString();\n   *  })\n   *  // => string[]\n   *\n   *  await text.custom(\\* async *\\(_text, index) => {\n   *    return index\n   *  })\n   *  // => number[]\n   * ```\n   */\n  async custom<T>(callback: TextCustomCallback<T>): Promise<Awaited<T>[]> {\n    return Promise.all(this.texts.map(async (text, index) => callback(text, index)));\n  }\n\n  /**\n   * compress core\n   *\n   * @param array - texts\n   * @param method - compress method\n   * @param gzipFn - gunzip function\n   * @param deflateFn - deflate function\n   * @param deflateRawFn - deflate raw function\n   * @param brotliCompressFn - brotli compress function\n   * @param options - compress option for each method\n   * @returns - base on what your functions return\n   */\n  static compress<R, T extends Buffer[] | Readable[], M extends TextCompressionMethods>(\n    array: T,\n    method: M,\n    gzipFn: TextCompressFn<R, T[number], M>,\n    deflateFn: TextCompressFn<R, T[number], M>,\n    deflateRawFn: TextCompressFn<R, T[number], M>,\n    brotliCompressFn: TextCompressFn<R, T[number], M>,\n    options?: TextCompressionOptions<M>,\n  ): R[] {\n    return array.map((text) => {\n      switch (method) {\n        case \"gzip\":\n          return gzipFn(text, options);\n        case \"deflate\":\n          return deflateFn(text, options);\n        case \"deflate-raw\":\n          return deflateRawFn(text, options);\n        case \"brotli-compress\":\n          return brotliCompressFn(text, options);\n        default:\n          throw new TypeError(`${Text.name}: Invalid compression method (${method})`);\n      }\n    });\n  }\n\n  /**\n   * decompress core\n   *\n   * @param array - texts\n   * @param method - decompress method\n   * @param gunzipFn - gunzip function\n   * @param inflateFn - inflate function\n   * @param inflateRawFn - inflate raw function\n   * @param brotliDecompressFn - brotli decompress function\n   * @param unzipFn - unzip function\n   * @param options - decompress option for each method\n   * @returns - base on what your functions return\n   */\n  static decompress<R, T extends Buffer[] | Readable[], M extends TextDecompressionMethods>(\n    array: T,\n    method: M,\n    gunzipFn: TextDecompressFn<R, T[number], M>,\n    inflateFn: TextDecompressFn<R, T[number], M>,\n    inflateRawFn: TextDecompressFn<R, T[number], M>,\n    brotliDecompressFn: TextDecompressFn<R, T[number], M>,\n    unzipFn: TextDecompressFn<R, T[number], M>,\n    options?: TextDecompressionOptions<M>,\n  ): R[] {\n    return array.map((text) => {\n      switch (method) {\n        case \"gunzip\":\n          return gunzipFn(text, options);\n        case \"inflate\":\n          return inflateFn(text, options);\n        case \"inflate-raw\":\n          return inflateRawFn(text, options);\n        case \"brotli-decompress\":\n          return brotliDecompressFn(text, options);\n        case \"unzip\":\n          return unzipFn(text, options);\n        default:\n          throw new TypeError(`${Text.name}: Invalid decompression method (${method})`);\n      }\n    });\n  }\n\n  /**\n   *\n   * @returns - filter non text\n   *\n   * @example\n   * ```js\n   *  const text1 = await Text.loadFile(\"text1.txt\")\n   *  const text2 = await Text.loadFile(\"text2.txt\")\n   *\n   *  const buffer = await Text.filter(text1, text2)\n   *  // => Buffer[]\n   * ```\n   */\n  static async filter(...texts: Buffer[]) {\n    return new FilterFile(...texts).text();\n  }\n\n  /**\n   * @throws\n   *\n   * load texts from files\n   * @returns - loaded files\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromFile(\"image.png\")\n   *  // => Text\n   *\n   *  const text = await Text.fromFile(\"image.png\", \"text.txt\")\n   *  // => Text\n   *  const length = text.length\n   *  // => 2\n   *\n   *  const text = await Text.fromFile(\"\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromFile(...path: string[]) {\n    const buffer = await loader.loadFile(path);\n    return Text.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * load texts from urls\n   * @returns - loaded urls\n   *\n   * @example\n   * ```js\n   *  const text = await Text.fromUrl(\"http://example.com/text.txt\")\n   *  // => Text\n   *\n   *  const text = await Text.fromUrl(\"http://example.com/image.png\", \"http://example.com/text.txt\")\n   *  // => Text\n   *  const length = text.length\n   *  // => 2\n   *\n   *  const text = await Text.fromUrl(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await loader.loadUrl(url);\n    return Text.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * @param texts - texts buffer\n   * @returns - create new safe instance\n   *\n   * @example\n   * ```js\n   *  const text = await Text.new(Buffer.alloc(0))\n   *  // => Error (throw)\n   *\n   *  const textFile = await Text.loadFile(\"text.txt\")\n   *\n   *  // filter non text\n   *  const text = await Text.new(textFile, Buffer.alloc(0))\n   *  // => Text\n   *  const length = text.length\n   *  // => 1\n   * ```\n   */\n  static new(texts: Buffer[]) {\n    const filtered = texts.filter((text) => text.length > 0);\n    if (filtered.length === 0) throw new Error(`${Text.name}: Non valid text`);\n    return new Text(...filtered);\n  }\n\n  /**\n   * check if an object is instance of Text or not\n   * @returns - boolean\n   *\n   * @example\n   * ```js\n   *  const text = new Text()\n   *  const isText = Text.isText(text)\n   *  // => true\n   *\n   *  const object = new Object()\n   *  const isNotText = Text.isText(object)\n   *  // => false\n   * ```\n   */\n  static isText(obj: unknown): obj is Text {\n    return obj instanceof Text;\n  }\n\n  // Async Compression //\n\n  static async gzipAsync(text: Buffer, options: GzipOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.gzip(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async deflateAsync(text: Buffer, options: DeflateOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.deflate(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async deflateRawAsync(text: Buffer, options: DeflateRawOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.deflateRaw(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async brotliCompressAsync(text: Buffer, options: BrotliCompressOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.brotliCompress(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  // Async decompression //\n\n  static async gunzipAsync(text: Buffer, options: GunzipOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.gunzip(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async inflateAsync(text: Buffer, options: InflateOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.inflate(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async inflateRawAsync(text: Buffer, options: InflateRawOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.inflateRaw(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async brotliDecompressAsync(text: Buffer, options: BrotliDecompressOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.brotliDecompress(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async unzipAsync(text: Buffer, options: UnzipOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.unzip(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  // Stream compression //\n\n  static gzipStream(readable: Readable, options: GzipOptions = {}) {\n    const gzip = zlib.createGzip(options);\n    return Core.stream(readable, gzip);\n  }\n\n  static deflateStream(readable: Readable, options: DeflateOptions = {}) {\n    const deflate = zlib.createDeflate(options);\n    return Core.stream(readable, deflate);\n  }\n\n  static deflateRawStream(readable: Readable, options: DeflateRawOptions = {}) {\n    const deflateRaw = zlib.createDeflateRaw(options);\n    return Core.stream(readable, deflateRaw);\n  }\n\n  static brotliCompressStream(readable: Readable, options: BrotliCompressOptions = {}) {\n    const brotliCompress = zlib.createBrotliCompress(options);\n    return Core.stream(readable, brotliCompress);\n  }\n\n  // Stream decompression //\n\n  static gunzipStream(readable: Readable, options: GunzipOptions = {}) {\n    const gunzip = zlib.createGunzip(options);\n    return Core.stream(readable, gunzip);\n  }\n\n  static inflateStream(readable: Readable, options: InflateOptions = {}) {\n    const inflate = zlib.createInflate(options);\n    return Core.stream(readable, inflate);\n  }\n\n  static inflateRawStream(readable: Readable, options: InflateRawOptions = {}) {\n    const inflateRaw = zlib.createInflateRaw(options);\n    return Core.stream(readable, inflateRaw);\n  }\n\n  static brotliDecompressStream(readable: Readable, options: BrotliDecompressOptions = {}) {\n    const brotliDecompress = zlib.createBrotliDecompress(options);\n    return Core.stream(readable, brotliDecompress);\n  }\n\n  static unzipStream(readable: Readable, options: UnzipOptions = {}) {\n    const unzip = zlib.createUnzip(options);\n    return Core.stream(readable, unzip);\n  }\n\n  // Sync compression //\n\n  static gzipSync(buffer: Buffer, options: GzipOptions = {}) {\n    return zlib.gzipSync(buffer, options);\n  }\n\n  static deflateSync(buffer: Buffer, options: DeflateOptions = {}) {\n    return zlib.deflateSync(buffer, options);\n  }\n\n  static deflateRawSync(buffer: Buffer, options: DeflateRawOptions = {}) {\n    return zlib.deflateRawSync(buffer, options);\n  }\n\n  static brotliCompressSync(buffer: Buffer, options: BrotliCompressOptions = {}) {\n    return zlib.brotliCompressSync(buffer, options);\n  }\n\n  // Sync decompression //\n\n  static gunzipSync(buffer: Buffer, options: GunzipOptions = {}) {\n    return zlib.gunzipSync(buffer, options);\n  }\n\n  static inflateSync(buffer: Buffer, options: InflateOptions = {}) {\n    return zlib.inflateSync(buffer, options);\n  }\n\n  static inflateRawSync(buffer: Buffer, options: InflateRawOptions = {}) {\n    return zlib.inflateRawSync(buffer, options);\n  }\n\n  static brotliDecompressSync(buffer: Buffer, options: BrotliDecompressOptions = {}) {\n    return zlib.brotliDecompressSync(buffer, options);\n  }\n\n  static unzipSync(buffer: Buffer, options: UnzipOptions = {}) {\n    return zlib.unzipSync(buffer, options);\n  }\n}\n", "import type { Readable } from \"node:stream\";\nimport type {\n  CSVCustomCallback,\n  CSVSetCallback,\n  GenerateOptions,\n  ParseOptions,\n  StringifyInput,\n  StringifyOptions,\n  TransformHandler,\n  TransformOptions,\n  TransformSyncHandler,\n} from \"../types/index.js\";\nimport * as csv from \"csv\";\nimport * as csvSync from \"csv/sync\";\nimport { FilterFile, loader, parser } from \"../helper/index.js\";\nimport Core from \"./core.js\";\n\nexport default class CSV extends Core {\n  private csvs: Buffer[];\n\n  /**\n   * Create unsafe instance\n   *\n   * to create safe instance:\n   * ```js\n   *  const csvFile = await CSV.loadFile(\"csv.csv\")\n   *\n   *  // create safe new instance\n   *  const csv = CSV.new(csvFile)\n   *  // => CSV\n   * ```\n   */\n  constructor(...csvs: Buffer[]) {\n    super();\n    this.csvs = csvs;\n  }\n\n  /** get current length of csvs */\n  get length() {\n    return this.csvs.length;\n  }\n\n  /**\n   * get csvs of this instance\n   *\n   * @example\n   * ```js\n   *  const buffer = await CSV.loadFile(\"csv.csv\")\n   *\n   *  // not the same reference\n   *  const csvs = new CSV(buffer).getCsvs()\n   *  // => Buffer[]\n   * ```\n   */\n  getCsvs() {\n    return [...this.csvs];\n  }\n\n  /**\n   * set csvs\n   *\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *\n   *  // this method filter invalid csvs before set\n   *  const newLength = await csv.setCsvs(\\* async *\\(csv, index) => {\n   *    return index % 2 ? csv : csv.toString()\n   *  })\n   *  // => 0\n   * ```\n   */\n  async setCsvs<T>(callback: CSVSetCallback<T>) {\n    const csvs = await Promise.all(this.csvs.map(async (csv, index) => callback(csv, index)));\n    const filteredCsvs = csvs.filter((csv) => Buffer.isBuffer(csv) && csv.length > 0) as Buffer[];\n    this.csvs = filteredCsvs;\n    return this.length;\n  }\n\n  /**\n   *\n   * @param csvs - new csvs (Buffer) to append the exists list\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const csv = new CSV()\n   *  const buffer1 = await CSV.loadFile(\"csv1.csv\")\n   *  const buffer2 = await CSV.loadFile(\"csv2.csv\")\n   *\n   *  // filter invalid csvs\n   *  await csv.append(buffer1, Buffer.alloc(0), buffer2)\n   *  // => 2\n   * ```\n   */\n  override async append(...csvs: Buffer[]) {\n    // const filteredCsvs = await CSV.filter(...csvs);\n    const filteredCsvs = csvs.filter((csv) => Buffer.isBuffer(csv) && csv.length > 0) as Buffer[];\n    this.csvs.push(...filteredCsvs);\n    return this.length;\n  }\n\n  /**\n   *\n   * @param csvs - extend csvs from instance to an another\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const buffer1 = await CSV.loadFile(\"csv1.csv\")\n   *  const buffer2 = await CSV.loadFile(\"csv2.csv\")\n   *  const csv1 = new CSV(buffer1, buffer2)\n   *\n   *  const csv2 = new CSV()\n   *\n   *  // don't apply any filters\n   *  csv2.extend(csv1)\n   *  // => 2\n   * ```\n   */\n  override extend(...csvs: CSV[]) {\n    csvs.forEach((csv) => {\n      this.csvs.push(...csv.getCsvs());\n    });\n    return this.length;\n  }\n\n  /**\n   *\n   * @returns - clone current instance\n   *\n   * @example\n   * ```js\n   *  const csv = new CSV()\n   *\n   *  // not the same reference\n   *  const clone = csv.clone()\n   *  // => CSV\n   * ```\n   */\n  override clone() {\n    return new CSV(...this.csvs);\n  }\n\n  /**\n   * Clean csvs array, to free memory\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv1.csv\", \"csv2.csv\")\n   *\n   *  // Some operations\n   *\n   *  csv.clean()\n   *\n   *  // Some operations\n   *\n   *  csv.append(Buffer.alloc(1))\n   * ```\n   */\n  override clean() {\n    this.csvs = [];\n  }\n\n  /**\n   * filter csvs\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const csv = new CSV(Buffer.alloc(1))\n   *  await csv.filter()\n   *  // => 0\n   * ```\n   */\n  override async filter() {\n    this.csvs = await CSV.filter(...this.csvs);\n    return this.length;\n  }\n\n  /**\n   * @returns - csvs metadata\n   *\n   * @example\n   * ```js\n   *  const csv1 = await CSV.loadFile(\"csv1.csv\")\n   *  const csv2 = await CSV.loadFile(\"csv2.csv\")\n   *\n   *  const csv = new CSV(csv1, csv2)\n   *  const metadata = await csv.metadata()\n   *  // => { size: number; rows: any; columns: any; }[]\n   * ```\n   */\n  override async metadata(options?: ParseOptions) {\n    return this.custom(async (csv) => {\n      const parse = await CSV.parseAsync(csv, options);\n      return {\n        size: csv.length,\n        rows: parse.length,\n        columns: parse?.[0]?.length ?? 0,\n      };\n    });\n  }\n\n  // Async //\n\n  /**\n   * parse csv\n   *\n   * @param options - parse options\n   * @returns - array contain csv data\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  const parsed = await csv.parseAsync()\n   *  // => any[][]\n   * ```\n   */\n  async parseAsync<P = any>(options?: ParseOptions) {\n    return this.custom((c) => CSV.parseAsync<Buffer, P>(c, options));\n  }\n\n  /**\n   *\n   * @param parsed - parsed csv\n   * @param handler - function to handle csv input\n   * @param options - transform options\n   * @returns - array contain new transformed csv\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  const parsed = await csv.parseAsync()\n   *  const transformed = await csv.transformAsync(parsed, (record) => {\n   *    record.push(record.shift());\n   *    return record;\n   *  })\n   *  // => any[][]\n   * ```\n   */\n  async transformAsync<T, U, P = any>(parsed: any[], handler: TransformHandler<T, U>, options?: TransformOptions) {\n    return Promise.all(parsed.map((p) => CSV.transformAsync<T, U, P>(p, handler, options)));\n  }\n\n  /**\n   * Convert array to csv string\n   * @param csvs - csv array\n   * @param options - stringify options\n   * @returns - string in csv format\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  const parsed = await csv.parseAsync()\n   *  const stringified = await CSV.stringifyAsync(parsed)\n   *  // => string[]\n   * ```\n   */\n  async stringifyAsync(csvs: StringifyInput, options?: StringifyOptions) {\n    return Promise.all(csvs.map((c) => CSV.stringifyAsync(c, options)));\n  }\n\n  // Stream //\n\n  /**\n   * parse csv\n   *\n   * @param options - parse options\n   * @returns - array contain csv data\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  const parsed = await csv.parseStream()\n   *  // => Writable[][]\n   * ```\n   */\n  async parseStream(options?: ParseOptions) {\n    const reads = await parser.toReadable(this.csvs);\n    return reads.map((csv) => CSV.parseStream(csv, options));\n  }\n\n  /**\n   *\n   * @param parsed - parsed csv\n   * @param handler - function to handle csv input\n   * @param options - transform options\n   * @returns - array contain new transformed csv\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  const parsed = await csv.parseAsync()\n   *  const transformed = await csv.transformStream(parsed, (record) => {\n   *    record.push(record.shift());\n   *    return record;\n   *  })\n   *  // => Writable[][]\n   * ```\n   */\n  async transformStream<T, U>(parsed: any[], handler: TransformHandler<T, U>, options?: TransformOptions) {\n    const reads = await parser.toReadable(parsed);\n    return reads.map((csv) => CSV.transformStream(csv, handler, options));\n  }\n\n  /**\n   * Convert array to csv string\n   * @param csvs - csv array\n   * @param options - stringify options\n   * @returns - string in csv format\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  const parsed = await csv.parseAsync()\n   *  const stringified = await CSV.stringifyStream(parsed)\n   *  // => Writable[]\n   * ```\n   */\n  async stringifyStream(csvs: StringifyInput, options?: StringifyOptions) {\n    const reads = await parser.toReadable(csvs);\n    return reads.map((csv) => CSV.stringifyStream(csv, options));\n  }\n\n  // Sync //\n\n  /**\n   * parse csv\n   *\n   * @param options - parse options\n   * @returns - array contain csv data\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  const parsed = csv.parseSync()\n   *  // => any[][]\n   * ```\n   */\n  parseSync(options?: ParseOptions) {\n    return this.csvs.map((c) => CSV.parseSync(c, options));\n  }\n\n  /**\n   *\n   * @param parsed - parsed csv\n   * @param handler - function to handle csv input\n   * @param options - transform options\n   * @returns - array contain new transformed csv\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  const parsed = await csv.parseAsync()\n   *  const transformed = csv.transformSync(parsed, (record) => {\n   *    record.push(record.shift());\n   *    return record;\n   *  })\n   *  // => any[][]\n   * ```\n   */\n  transformSync<T, U>(parsed: any[], handler: TransformSyncHandler<T, U>, options?: TransformOptions) {\n    return parsed.map((p) => CSV.transformSync(p, handler, options));\n  }\n\n  /**\n   * Convert array to csv string\n   * @param csvs - csv array\n   * @param options - stringify options\n   * @returns - string in csv format\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  const parsed = await csv.parseAsync()\n   *  const stringified = CSV.stringifySync(parsed)\n   *  // => string[]\n   * ```\n   */\n  stringifySync(csvs: StringifyInput, options?: StringifyOptions) {\n    return csvs.map((c) => CSV.stringifySync(c, options));\n  }\n\n  /**\n   * @returns - base on the callback return type\n   *\n   * @example\n   * ```js\n   *  const csv1 = await CSV.loadFile(\"csv1.csv\")\n   *  const csv2 = await CSV.loadFile(\"csv2.csv\")\n   *\n   *  const csv = new CSV(csv1, csv2)\n   *\n   *  await csv.custom(\\* async *\\(csv, _index) => {\n   *    return csv.toString();\n   *  })\n   *  // => string[]\n   *\n   *  await csv.custom(\\* async *\\(_csv, index) => {\n   *    return index\n   *  })\n   *  // => number[]\n   * ```\n   */\n  async custom<T>(callback: CSVCustomCallback<T>): Promise<Awaited<T>[]> {\n    return Promise.all(this.csvs.map(async (csv, index) => callback(csv, index)));\n  }\n\n  /**\n   *\n   * @returns - filter non csv\n   *\n   * @example\n   * ```js\n   *  const csv1 = await CSV.loadFile(\"csv1.csv\")\n   *  const csv2 = await CSV.loadFile(\"csv2.csv\")\n   *\n   *  const buffer = await CSV.filter(csv1, csv2)\n   *  // => Buffer[]\n   * ```\n   */\n  static async filter(...csvs: Buffer[]) {\n    return new FilterFile(...csvs).custom(\"csv\");\n  }\n\n  /**\n   * @throws\n   *\n   * load csvs from files\n   * @returns - loaded files\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromFile(\"csv.csv\")\n   *  // => CSV\n   *\n   *  const csv = await CSV.fromFile(\"csv1.csv\", \"csv2.csv\")\n   *  // => CSV\n   *  const length = csv.length\n   *  // => 2\n   *\n   *  const csv = await CSV.fromFile(\"\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromFile(...path: string[]) {\n    const buffer = await loader.loadFile(path);\n    return CSV.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * load csvs from urls\n   * @returns - loaded urls\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.fromUrl(\"http://example.com/csv.csv\")\n   *  // => CSV\n   *\n   *  const csv = await CSV.fromUrl(\"http://example.com/csv.csv\", \"http://example.com/csv.csv\")\n   *  // => CSV\n   *  const length = csv.length\n   *  // => 2\n   *\n   *  const csv = await CSV.fromUrl(\"csv.csv\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await loader.loadUrl(url);\n    return CSV.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * @param csvs - csvs buffer\n   * @returns - create new safe instance\n   *\n   * @example\n   * ```js\n   *  const csv = await CSV.new(Buffer.alloc(0))\n   *  // => Error (throw)\n   *\n   *  const csvFile = await CSV.loadFile(\"csv.csv\")\n   *\n   *  // filter non csv\n   *  const csv = await CSV.new(csvFile, Buffer.alloc(0))\n   *  // => CSV\n   *  const length = csv.length\n   *  // => 1\n   * ```\n   */\n  static new(csvs: Buffer[]) {\n    const filtered = csvs.filter((csv) => csv.length > 0);\n    if (filtered.length === 0) throw new Error(`${CSV.name}: Non valid csv`);\n    return new CSV(...filtered);\n  }\n\n  /**\n   * check if an object is instance of CSV or not\n   * @returns - boolean\n   *\n   * @example\n   * ```js\n   *  const csv = new CSV()\n   *  const isCSV = CSV.isCSV(csv)\n   *  // => true\n   *\n   *  const object = new Object()\n   *  const isNotCSV = CSV.isCSV(object)\n   *  // => false\n   * ```\n   */\n  static isCSV(obj: unknown): obj is CSV {\n    return obj instanceof CSV;\n  }\n\n  // Async //\n\n  static async generateAsync<P = any>(options: GenerateOptions = {}) {\n    return new Promise<P>((resolve, reject) => {\n      csv.generate(options, (err, records) => {\n        if (err) return reject(err);\n        resolve(records);\n      });\n    });\n  }\n\n  static async parseAsync<T extends Buffer | string, P = any>(input: T, options: ParseOptions = {}) {\n    return new Promise<P>((resolve, reject) => {\n      csv.parse(input, options, (err, records) => {\n        if (err) return reject(err);\n        resolve(records);\n      });\n    });\n  }\n\n  static async transformAsync<T, U, P = any>(\n    records: T[],\n    handler: TransformHandler<T, U>,\n    options: TransformOptions = {},\n  ) {\n    return new Promise<P>((resolve, reject) => {\n      csv.transform(records, options, handler, (err, records) => {\n        if (err) return reject(err);\n        resolve(records as P);\n      });\n    });\n  }\n\n  static async stringifyAsync(input: StringifyInput, options: StringifyOptions = {}) {\n    return new Promise<string>((resolve, reject) => {\n      csv.stringify(input, options, (err, str) => {\n        if (err) return reject(err);\n        resolve(str);\n      });\n    });\n  }\n\n  // Stream //\n\n  static generateStream(options: GenerateOptions = {}) {\n    return csv.generate(options);\n  }\n\n  static parseStream(readable: Readable, options: ParseOptions = {}) {\n    return Core.stream(readable, csv.parse(options));\n  }\n\n  static transformStream<T, U>(readable: Readable, handler: TransformHandler<T, U>, options: TransformOptions = {}) {\n    return Core.stream(readable, csv.transform(options, handler));\n  }\n\n  static stringifyStream(readable: Readable, options: StringifyOptions = {}) {\n    return Core.stream(readable, csv.stringify(options));\n  }\n\n  // Sync //\n\n  static generateSync(options: GenerateOptions = {}) {\n    return csvSync.generate(options);\n  }\n\n  static parseSync<T extends Buffer | string>(input: T, options: ParseOptions = {}) {\n    return csvSync.parse(input, options);\n  }\n\n  static transformSync<T, U>(records: T[], handler: TransformSyncHandler<T, U>, options: TransformOptions = {}) {\n    return csvSync.transform(records, options, handler);\n  }\n\n  static stringifySync(input: StringifyInput, options: StringifyOptions = {}) {\n    return csvSync.stringify(input, options);\n  }\n}\n", "import type { PDFOptions } from \"puppeteer\";\nimport type { CreateOptions, LoadOptions, PDFImage, SaveOptions } from \"pdf-lib\";\nimport type {\n  PdfCustomDocumentCallback,\n  PDFFromImageOptions,\n  PDFMergeOptions,\n  PDFSetCallback,\n} from \"../../types/index.js\";\nimport { PageSizes, PDFDocument } from \"pdf-lib\";\nimport { FilterFile, loader, parser } from \"../../helper/index.js\";\nimport Core from \"../core.js\";\n\nexport default class PDF extends Core {\n  private pdfs: Buffer[];\n\n  constructor(...pdfs: Buffer[]) {\n    super();\n    this.pdfs = pdfs;\n  }\n\n  /** get current length of pdfs */\n  get length() {\n    return this.pdfs.length;\n  }\n\n  /**\n   * get pdfs of this instance\n   *\n   * @example\n   * ```js\n   *  const buffer = await PDF.loadFile(\"pdf.pdf\")\n   *\n   *  // not the same reference\n   *  const pdfs = new PDF(buffer).getPdfs()\n   *  // => Buffer[]\n   * ```\n   */\n  getPdfs() {\n    return [...this.pdfs];\n  }\n\n  /**\n   * set pdfs\n   *\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromFile(\"pdf.pdf\")\n   *\n   *  // this method filter invalid pdfs before set\n   *  const newLength = await pdf.setPdfs(\\* async *\\(pdf, index) => {\n   *    return index % 2 ? pdf : pdf.toString()\n   *  })\n   *  // => 0\n   * ```\n   */\n  async setPdfs<T>(callback: PDFSetCallback<T>) {\n    const pdfs = await Promise.all(this.pdfs.map(async (pdf, index) => callback(pdf, index)));\n    const filteredPdfs = pdfs.filter((pdf) => Buffer.isBuffer(pdf) && pdf.length > 0) as Buffer[];\n    const validPdfs = await PDF.filter(...filteredPdfs);\n    this.pdfs = validPdfs;\n    return this.length;\n  }\n\n  /**\n   *\n   * @param pdfs - new pdfs (Buffer) to append the exists list\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const pdf = new PDF()\n   *  const buffer1 = await PDF.loadFile(\"pdf1.pdf\")\n   *  const buffer2 = await PDF.loadFile(\"pdf2.pdf\")\n   *\n   *  // filter invalid pdfs\n   *  await pdf.append(buffer1, Buffer.alloc(1), buffer2)\n   *  // => 2\n   * ```\n   */\n  override async append(...pdfs: Buffer[]) {\n    const filteredPdfs = await PDF.filter(...pdfs);\n    this.pdfs.push(...filteredPdfs);\n    return this.length;\n  }\n\n  /**\n   *\n   * @param pdfs - extend pdfs from instance to an another\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const buffer1 = await PDF.loadFile(\"pdf1.pdf\")\n   *  const buffer2 = await PDF.loadFile(\"pdf2.pdf\")\n   *  const pdf1 = new PDF(buffer1, buffer2)\n   *\n   *  const pdf2 = new PDF()\n   *\n   *  // don't apply any filters\n   *  pdf2.extend(pdf1)\n   *  // => 2\n   * ```\n   */\n  override extend(...pdfs: PDF[]) {\n    pdfs.forEach((pdf) => {\n      this.pdfs.push(...pdf.getPdfs());\n    });\n    return this.length;\n  }\n\n  /**\n   *\n   * @returns - clone current instance\n   *\n   * @example\n   * ```js\n   *  const pdf = new PDF()\n   *\n   *  // not the same reference\n   *  const clone = pdf.clone()\n   *  // => PDF\n   * ```\n   */\n  override clone() {\n    return new PDF(...this.pdfs);\n  }\n\n  /**\n   * Clean pdfs array, to free memory\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromFile(\"pdf1.pdf\", \"pdf2.pdf\")\n   *\n   *  // Some operations\n   *\n   *  pdf.clean()\n   *\n   *  // Some operations\n   *\n   *  pdf.append(Buffer.alloc(1))\n   * ```\n   */\n  override clean() {\n    this.pdfs = [];\n  }\n\n  /**\n   * filter pdfs\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const pdf = new PDF(Buffer.alloc(1))\n   *  await pdf.filter()\n   *  // => 0\n   * ```\n   */\n  override async filter() {\n    this.pdfs = await PDF.filter(...this.pdfs);\n    return this.length;\n  }\n\n  /**\n   *\n   * @param options load options\n   * @returns pdf document\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromFile(\"pdf1.pdf\", \"pdf2.pdf\")\n   *  const documents = await pdf.getDocuments()\n   *  // => PDFDocument[]\n   * ```\n   */\n  async getDocuments(options?: LoadOptions) {\n    return Promise.all(this.pdfs.map((pdf) => PDF.load(pdf.buffer, options)));\n  }\n\n  /**\n   * @returns pdfs metadata\n   *\n   * @example\n   * ```js\n   *  const pdf1 = await PDF.loadFile(\"pdf1.pdf\")\n   *  const pdf2 = await PDF.loadFile(\"pdf2.pdf\")\n   *\n   *  const pdf = new PDF(pdf1, pdf2)\n   *  const metadata = await pdf.metadata()\n   *  // => Metadata[]\n   * ```\n   */\n  override async metadata(options?: LoadOptions) {\n    return this.custom((document) => {\n      return {\n        title: document.getTitle(),\n        author: document.getAuthor(),\n        subject: document.getSubject(),\n        creator: document.getCreator(),\n        keywords: document.getKeywords(),\n        producer: document.getProducer(),\n        pageCount: document.getPageCount(),\n        pageIndices: document.getPageIndices(),\n        creationDate: document.getCreationDate(),\n        modificationDate: document.getModificationDate(),\n      };\n    }, options);\n  }\n\n  /**\n   *\n   * @param options load options\n   * @returns pdf pages\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromFile(\"pdf1.pdf\", \"pdf2.pdf\")\n   *  const pages = await pdf.getPages()\n   *  // => PDFPage[][]\n   * ```\n   */\n  async getPages(options?: LoadOptions) {\n    return this.custom((document) => document.getPages(), options);\n  }\n\n  /**\n   *\n   * @param options load options\n   * @returns pdf form\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromFile(\"pdf1.pdf\", \"pdf2.pdf\")\n   *  const pages = await pdf.getForm()\n   *  // => PDFForm[]\n   * ```\n   */\n  async getForm(options?: LoadOptions) {\n    return this.custom((document) => document.getForm(), options);\n  }\n\n  /**\n   * merge all pdfs in one pdf\n   * @param options merge options\n   * @returns merged pdf\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromFile(\"pdf1.pdf\", \"pdf2.pdf\")\n   *  const merge = await pdf.merge()\n   *  // => Buffer\n   * ```\n   */\n  async merge(options?: PDFMergeOptions) {\n    const merge = await PDF.create(options?.create);\n    const copies = await this.custom((document) => merge.copyPages(document, document.getPageIndices()), options?.load);\n    copies.forEach((copied) => copied.forEach((page) => merge.addPage(page)));\n    return PDF.save(merge);\n  }\n\n  /**\n   *\n   * @param options load options\n   * @returns base on what your callback return\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromFile(\"pdf1.pdf\", \"pdf2.pdf\")\n   *\n   *  await pdf.custom((document, _index) => {\n   *    return PDF.save(document)\n   *  })\n   *  // => Buffer[]\n   *\n   *  await pdf.custom((_document, index) => index)\n   *  // => number[]\n   * ```\n   */\n  async custom<T>(callback: PdfCustomDocumentCallback<T>, options?: LoadOptions): Promise<Awaited<T>[]> {\n    const documents = await this.getDocuments(options);\n    return Promise.all(documents.map(async (document, index) => callback(document, index)));\n  }\n\n  /**\n   * @throws\n   *\n   * load pdfs from files\n   * @returns - loaded files\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromFile(\"pdf.pdf\")\n   *  // => PDF\n   *\n   *  const pdf = await PDF.fromFile(\"pdf.pdf\", \"text.txt\")\n   *  // => PDF\n   *  const length = pdf.length\n   *  // => 1\n   *\n   *  const text = await PDF.fromFile(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromFile(...path: string[]) {\n    const buffer = await loader.loadFile(path);\n    return PDF.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * load pdfs from urls\n   * @returns - loaded urls\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromUrl(\"http://example.com/pdf.pdf\")\n   *  // => PDF\n   *\n   *  const pdf = await PDF.fromUrl(\"http://example.com/pdf.pdf\", \"http://example.com/text.txt\")\n   *  // => PDF\n   *  const length = pdf.length\n   *  // => 1\n   *\n   *  const text = await PDF.fromUrl(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await loader.loadUrl(url);\n    return PDF.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * @param images - images buffer\n   * @param options - convert options\n   *\n   * @example\n   * ```js\n   *  // image buffer\n   *  const image = Buffer.alloc(1)\n   *  const pdf = await PDF.fromImage(image)\n   *  // => PDFDocument | PDFDocument[]\n   * ```\n   */\n  static async fromImage<T extends Buffer>(images: T, options?: PDFFromImageOptions): Promise<PDFDocument>;\n  static async fromImage<T extends Buffer[]>(images: T, options?: PDFFromImageOptions): Promise<PDFDocument[]>;\n  static async fromImage<T extends Buffer | Buffer[]>(images: T, options: PDFFromImageOptions = {}) {\n    if (Array.isArray(images)) return Promise.all(images.map((image) => PDF.fromImage(image, options)));\n\n    const [isPNG, isJPG] = await Promise.all([\n      new FilterFile(images).custom(\"png\"),\n      new FilterFile(images).custom(\"jpg\"),\n    ]);\n    if (isJPG.length === 0 && isPNG.length === 0) throw new Error(`${PDF.name}: Invalid images to convert to pdf`);\n\n    const { pageSize = PageSizes.A4, scaleImage, position } = options;\n\n    const pdf = await PDFDocument.create(options.create);\n    const page = pdf.addPage(pageSize);\n    const pageDimensions = page.getSize();\n\n    let pdfImage: PDFImage;\n    if (isPNG.length > 0) {\n      pdfImage = await pdf.embedPng(images.buffer);\n    } else {\n      pdfImage = await pdf.embedJpg(images.buffer);\n    }\n\n    let imageDimensions = pdfImage.size();\n    if (typeof scaleImage === \"number\") {\n      imageDimensions = pdfImage.scale(scaleImage);\n    } else if (Array.isArray(scaleImage)) {\n      imageDimensions = pdfImage.scaleToFit(scaleImage[0], scaleImage[1]);\n    } else {\n      imageDimensions = pdfImage.scaleToFit(pageDimensions.width, pageDimensions.height);\n    }\n\n    page.drawImage(pdfImage, {\n      x: position?.[0] ?? 0,\n      y: position?.[1] ?? 0,\n      width: imageDimensions.width,\n      height: imageDimensions.height,\n    });\n\n    return pdf;\n  }\n\n  /**\n   * @deprecated\n   * Generate pdf from websites\n   */\n  static async generate<T extends string>(htmls: T, options?: PDFOptions): Promise<Buffer>;\n  static async generate<T extends string[]>(htmls: T, options?: PDFOptions): Promise<Buffer[]>;\n  static async generate<T extends string | string[]>(htmls: T, options?: PDFOptions) {\n    if (Array.isArray(htmls)) return Promise.all(htmls.map((html) => PDF.generate(html, options)));\n\n    const browser = await Core.initBrowser();\n    const page = await browser.newPage();\n\n    const res = await page.goto(htmls, { waitUntil: \"networkidle2\" });\n    if (res === null || !res.ok()) throw new Error(`${PDF.name}: Can't fetch (${htmls})`);\n\n    const buffer = await page.pdf(options);\n    await browser.close();\n    return buffer;\n  }\n\n  /**\n   *\n   * @returns filter non pdf\n   *\n   * @example\n   * ```js\n   *  const pdf1 = await PDF.loadFile(\"pdf1.pdf\")\n   *  const pdf2 = await PDF.loadFile(\"pdf2.pdf\")\n   *  const buffer = await PDF.filter(pdf1, pdf2)\n   *  // => Buffer[]\n   * ```\n   */\n  static async filter(...pdfs: Buffer[]) {\n    return new FilterFile(...pdfs).custom(\"pdf\");\n  }\n\n  /**\n   *\n   * @param pdfs - pdf document\n   * @param options - save options\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.fromFile(\"pdf.pdf\")\n   *  const documents = await pdf.getDocuments()\n   *  const buffer = await PDF.save(documents)\n   *  // => Buffer | Buffer[]\n   * ```\n   */\n  static async save<T extends PDFDocument>(pdfs: T, options?: SaveOptions): Promise<Buffer>;\n  static async save<T extends PDFDocument[]>(pdfs: T, options?: SaveOptions): Promise<Buffer[]>;\n  static async save<T extends PDFDocument | PDFDocument[]>(pdfs: T, options?: SaveOptions) {\n    if (Array.isArray(pdfs)) return Promise.all(pdfs.map((pdf) => PDF.save(pdf, options)));\n\n    const save = await pdfs.save(options);\n    return parser.toBuffer(save);\n  }\n\n  static async load<T extends string | Uint8Array | ArrayBuffer>(pdf: T, options?: LoadOptions) {\n    return PDFDocument.load(pdf, options);\n  }\n\n  static async create(options?: CreateOptions) {\n    return PDFDocument.create(options);\n  }\n\n  static document() {\n    return PDFDocument;\n  }\n\n  /**\n   * @throws\n   *\n   * @param pdfs - pdfs buffer\n   * @returns - create new safe instance\n   *\n   * @example\n   * ```js\n   *  const pdf = await PDF.new(Buffer.alloc(1))\n   *  // => Error (throw)\n   *\n   *  const pdfFile = await PDF.loadFile(\"pdf.pdf\")\n   *\n   *  // filter non pdf\n   *  const pdf = await PDF.new(pdfFile, Buffer.alloc(1))\n   *  // => PDF\n   *  const length = pdf.length\n   *  // => 1\n   * ```\n   */\n  static async new(pdfs: Buffer[]) {\n    const filtered = await PDF.filter(...pdfs);\n    if (filtered.length === 0) throw new Error(`${PDF.name}: Non valid pdf`);\n    return new PDF(...filtered);\n  }\n\n  /**\n   * check if an object is instance of PDF or not\n   * @returns - boolean\n   *\n   * @example\n   * ```js\n   *  const pdf = new PDF()\n   *  const isPDF = PDF.isPDF(pdf)\n   *  // => true\n   *\n   *  const object = new Object()\n   *  const isNotPDF = PDF.isPDF(object)\n   *  // => false\n   * ```\n   */\n  static isPDF(obj: unknown): obj is PDF {\n    return obj instanceof PDF;\n  }\n}\n", "// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\n//! New PDF processor focused on performance, still under development\n\n//? Why new PDF processor? pdf-lib is a great library designed for JS\n//? The library is not maintained from 3 years ago, making adding new\n//? Features hard, and require for more packages and configuration.\n//? Making more harder to maintain this package, and make performance\n//? Not the best think.\n\n//* The old version is still supported and maintained until,\n//* Finish with this version or rollback to the old.\n\n//* This version is based on mupdf (https://mupdf.com/), a library\n//* written in C, make it the best choice.\n\nimport * as mupdf from \"mupdf\";\nimport Core from \"../core.js\";\n\nexport default class PDF_experimental {\n  private pdfs: Buffer[] = [];\n\n  constructor(...pdfs: Buffer[]) {\n    this.pdfs = pdfs;\n  }\n\n  /** @link https://mupdfjs.readthedocs.io/en/latest/how-to-guide/node/document/index.html#document-metadata */\n  async metadata() {\n    return this.custom((document) => {\n      return {\n        format: document.getMetaData(mupdf.Document.META_FORMAT),\n        encryption: document.getMetaData(mupdf.Document.META_ENCRYPTION),\n        author: document.getMetaData(mupdf.Document.META_INFO_AUTHOR),\n        title: document.getMetaData(mupdf.Document.META_INFO_TITLE),\n        subject: document.getMetaData(mupdf.Document.META_INFO_SUBJECT),\n        keywords: document.getMetaData(mupdf.Document.META_INFO_KEYWORDS),\n        creator: document.getMetaData(mupdf.Document.META_INFO_CREATOR),\n        producer: document.getMetaData(mupdf.Document.META_INFO_PRODUCER),\n        countUnsavedVersions: document.countUnsavedVersions(),\n        countVersions: document.countVersions(),\n        countObjects: document.countObjects(),\n        countPages: document.countPages(),\n        wasRepaired: document.wasRepaired(),\n        language: document.getLanguage(),\n        version: document.getVersion(),\n        creationDate: document.getMetaData(mupdf.Document.META_INFO_CREATIONDATE),\n        modificationDate: document.getMetaData(mupdf.Document.META_INFO_MODIFICATIONDATE),\n      };\n    });\n  }\n\n  /** @link https://mupdfjs.readthedocs.io/en/latest/how-to-guide/node/document/index.html#extracting-document-text */\n  async getTexts() {\n    return this.custom((document) => {\n      const texts: string[] = [];\n      const countPages = document.countPages();\n      for (let i = 0; i < countPages; i++) {\n        const page = document.loadPage(i);\n        texts.push(page.toStructuredText(\"preserve-whitespace\").asJSON());\n      }\n      return texts;\n    });\n  }\n\n  /** @link https://mupdfjs.readthedocs.io/en/latest/how-to-guide/node/document/index.html#extracting-document-images */\n  async getImages() {\n    return this.custom((document) => {\n      const images: Buffer[][] = [];\n      const countPages = document.countPages();\n\n      for (let i = 0; i < countPages; i++) {\n        const page = document.loadPage(i);\n        const pageImages: Buffer[] = [];\n\n        page.toStructuredText(\"preserve-images\").walk({\n          async onImageBlock(_bbox, _transform, image) {\n            const pixmap = image.toPixmap();\n            const png = pixmap.asPNG();\n            const buffer = await Core.toBuffer(png);\n            pageImages.push(buffer);\n          },\n        });\n\n        images.push(pageImages);\n      }\n\n      return images;\n    });\n  }\n\n  /** @link https://mupdfjs.readthedocs.io/en/latest/how-to-guide/node/document/index.html#extracting-document-annotations */\n  async annotations() {\n    return this.custom((document) => {\n      const annots: mupdf.PDFAnnotation[][] = [];\n      const countPages = document.countPages();\n      for (let i = 0; i < countPages; i++) {\n        const page = document.loadPage(i);\n        annots.push(page.getAnnotations());\n      }\n      return annots;\n    });\n  }\n\n  /** @link https://mupdfjs.readthedocs.io/en/latest/how-to-guide/node/document/index.html#getting-document-links */\n  async links() {\n    return this.custom((document) => {\n      const links: string[][] = [];\n      const countPages = document.countPages();\n\n      for (let i = 0; i < countPages; i++) {\n        const page = document.loadPage(i);\n\n        const pageLinks = page.getLinks().map((link) => ({\n          bounds: link.getBounds(),\n          link: link.getURI(),\n          isExternal: link.isExternal(),\n        }));\n\n        links.push(pageLinks);\n      }\n\n      return links;\n    });\n  }\n\n  /** @link https://mupdfjs.readthedocs.io/en/latest/how-to-guide/node/document/index.html#baking-a-document */\n  async bake(annots?: boolean, widget?: boolean) {\n    return this.custom((document) => {\n      document.bake(annots, widget);\n    });\n  }\n\n  /** @link https://mupdfjs.readthedocs.io/en/latest/how-to-guide/node/document/index.html#searching-a-document */\n  async search(s: string) {\n    return this.custom((document) => {});\n  }\n\n  async custom<T>(callback: (document: mupdf.PDFDocument, index: number) => T) {\n    return Promise.all(\n      this.pdfs.map(async (pdf, index) => {\n        const document = PDF_experimental.open(pdf);\n        return callback(document, index);\n      }),\n    );\n  }\n\n  static open(pdf: Buffer) {\n    return new mupdf.PDFDocument(pdf);\n  }\n\n  static needsPassword(pdf: Buffer) {\n    const document = PDF_experimental.open(pdf);\n    return document.needsPassword();\n  }\n}\n", "import type { AVCustomCallback } from \"../../types/index.js\";\nimport type { Readable } from \"node:stream\";\nimport ffmpeg, { type FfprobeData } from \"fluent-ffmpeg\";\nimport { path as ffmpegPath } from \"@ffmpeg-installer/ffmpeg\";\nimport { path as ffprobePath } from \"@ffprobe-installer/ffprobe\";\nimport path from \"node:path\";\nimport { FilterFile, loader, TmpFile } from \"../../helper/index.js\";\nimport Core from \"../core.js\";\n\nexport default abstract class AV extends Core {\n  protected avs: Buffer[];\n\n  constructor(...avs: Buffer[]) {\n    super();\n    this.avs = avs;\n  }\n\n  /** get current length of avs */\n  get length() {\n    return this.avs.length;\n  }\n\n  /**\n   * Clean avs array, to free memory\n   *\n   * @example\n   * ```js\n   *  const audio = await Audio.fromFile(\"audio1.wav\", \"audio2.mp3\")\n   *  const video = await Video.fromFile(\"video1.mov\", \"video2.mkv\")\n   *\n   *  // Some operations\n   *\n   *  audio.clean()\n   *  video.clean()\n   *\n   *  // Some operations\n   *\n   *  audio.append(Buffer.alloc(1))\n   *  video.append(Buffer.alloc(1))\n   * ```\n   */\n  override clean() {\n    this.avs = [];\n  }\n\n  /**\n   * @returns - avs metadata\n   *\n   * @example\n   * ```js\n   *  const av1 = await Audio.loadFile(\"av1.wav\")\n   *  const av2 = await Audio.loadFile(\"av2.wav\")\n   *\n   *  const av = new Audio(av1, av2)\n   *  const metadata = await av.metadata()\n   *  // => FfprobeData[]\n   * ```\n   */\n  override async metadata() {\n    return this.custom((command) => {\n      return new Promise<FfprobeData>((resolve, reject) => {\n        command.ffprobe((err, metadata) => {\n          if (err) return reject(err);\n          resolve(metadata);\n        });\n      });\n    });\n  }\n\n  /**\n   * @returns converted avs\n   *\n   * @example\n   * ```js\n   *  const av1 = await Audio.loadFile(\"av1.wav\")\n   *  const av2 = await Audio.loadFile(\"av2.wav\")\n   *\n   *  const av = new Audio(av1, av2)\n   *  const buffers = await av.convert(\"mp3\")\n   *  // => Buffer[]\n   * ```\n   */\n  async convert(format: string) {\n    return this.custom((command, tmpFile) => {\n      return new Promise<Buffer>((resolve, reject) => {\n        const output = path.join(tmpFile.tmp!.path, TmpFile.generateFileName(format));\n        command\n          .toFormat(format)\n          .on(\"end\", () => {\n            loader.loadFile(output).then(resolve, reject);\n          })\n          .on(\"error\", reject)\n          .output(output)\n          .run();\n      });\n    });\n  }\n\n  /**\n   * @throws\n   *\n   * @param duration av chunk duration (seconds)\n   * @param start start point @default 0\n   * @returns all av chunks\n   *\n   * @example\n   * ```js\n   *  const video = await Video.fromFile(\"video1.mp3\", \"video2.mkv\")\n   *  const chunks = await video.split(60)\n   *  // => Buffer[][]\n   * ```\n   */\n  async spilt(duration: number, start: number = 0) {\n    return this.custom(async (command, tmpFile, index) => {\n      const metadata = await new Promise<FfprobeData>((resolve, reject) => {\n        command.ffprobe((error, metadata) => {\n          if (error) return reject(error);\n          resolve(metadata);\n        });\n      });\n\n      const avDuration = metadata.format.duration ?? 0;\n      if (avDuration === 0) throw new Error(`${AV.name}: Empty av duration`);\n\n      if (start >= avDuration) throw new Error(`${AV.name}: start time is bigger then the av duration`);\n\n      const format = (await FilterFile.extension(this.avs[index]!)) ?? \"\";\n      if (format.length === 0) throw new Error(`${AV.name}: Unknown av format`);\n\n      //? High performance and High memory consumption\n      // const splitMap: { start: number; duration: number }[] = [];\n      // for (let start = 0; start < avDuration; start += duration) {\n      //   const validDuration = Math.min(duration, avDuration - start);\n      //   splitMap.push({ start, duration: validDuration });\n      // }\n\n      // return Promise.all(\n      //   splitMap.map(({ start, duration }) => {\n      //     return new Promise<Buffer>((resolve, reject) => {\n      //       const output = path.join(tmpFile.tmp!.path, TmpFile.generateFileName(format));\n      //       command\n      //         .setStartTime(start)\n      //         .setDuration(duration)\n      //         .on(\"end\", () => {\n      //           loadFile(output).then(resolve, reject);\n      //         })\n      //         .on(\"error\", reject)\n      //         .output(output)\n      //         .run();\n      //     });\n      //   }),\n      // );\n\n      const avPath = tmpFile.paths[index]!;\n      const chunks: Buffer[] = [];\n      let i = start;\n\n      while (i < avDuration) {\n        const validDuration = Math.min(duration, avDuration - i);\n        const output = path.join(tmpFile.tmp!.path, TmpFile.generateFileName(format));\n\n        const chunk = await new Promise<Buffer>((resolve, reject) => {\n          AV.newFfmpeg(avPath)\n            .setStartTime(i)\n            .setDuration(validDuration)\n            .on(\"end\", () => {\n              loader.loadFile(output).then(resolve, reject);\n            })\n            .on(\"error\", reject)\n            .output(output)\n            .run();\n        });\n\n        chunks.push(chunk);\n        i += validDuration;\n      }\n      return chunks;\n    });\n  }\n\n  /**\n   * merge all videos/audios in one video/audio\n   *\n   * @param format new format\n   * @returns new video/audio\n   *\n   * @example\n   * ```js\n   * ```\n   */\n  async merge(format: string, fps: number = 30) {\n    const converted = await this.convert(format);\n    const tmpFile = await new TmpFile(...converted).init();\n    const output = path.join(tmpFile.tmp!.path, TmpFile.generateFileName(format));\n\n    console.log(\"Merge start\");\n    const merged = await new Promise<Buffer>((resolve, reject) => {\n      const command = AV.newFfmpeg(tmpFile.paths[0]!);\n\n      tmpFile.paths.forEach((av, index) => {\n        if (index === 0) return;\n        command.input(av);\n      });\n\n      command\n        .fps(fps)\n        .on(\"start\", (commandLine) => {\n          console.log(\"Spawned FFmpeg with command: \" + commandLine);\n        })\n        .on(\"end\", () => {\n          loader.loadFile(output).then(resolve, reject);\n        })\n        .on(\"error\", reject)\n        .mergeToFile(output, tmpFile.tmp!.path);\n    });\n\n    await tmpFile.clean();\n    return merged;\n  }\n\n  /**\n   * @returns base on the callback return type\n   *\n   * @example\n   * ```js\n   *  const av1 = await Audio.loadFile(\"av1.wav\")\n   *  const av2 = await Audio.loadFile(\"av2.wav\")\n   *\n   *  const av = new Audio(av1, av2)\n   *\n   *  await av.custom(\\* async *\\(command, _index) => {\n   *    return new Promise<Buffer>((resolve, reject) => {\n   *      command.on(\"error\", reject).on(\"end\", () => {\n   *        resolve(\\* Some operations *\\)\n   *      })\n   *    })\n   *  })\n   *  // => Buffer[]\n   *\n   *  await av.custom(\\* async *\\(_command, index) => {\n   *    return index\n   *  })\n   *  // => number[]\n   * ```\n   */\n  async custom<T>(callback: AVCustomCallback<T>): Promise<Awaited<T>[]> {\n    const tmpFile = await new TmpFile(...this.avs).init();\n    const result = await Promise.all(\n      tmpFile.paths.map(async (path, index) => callback(AV.newFfmpeg(path), tmpFile, index)),\n    );\n    await tmpFile.clean();\n    return result;\n  }\n\n  /**\n   * @returns new instance of ffmpeg\n   *\n   * @example\n   * ```js\n   *  const command = Video.newFfmpeg(\"video.mp4\")\n   *  // => FfmpegCommand\n   * ```\n   */\n  static newFfmpeg<T extends Readable | string>(av: T, options?: ffmpeg.FfmpegCommandOptions) {\n    return ffmpeg(options).clone().setFfmpegPath(ffmpegPath).setFfprobePath(ffprobePath).input(av);\n  }\n}\n", "import type { AVSetCallback } from \"../../types/index.js\";\nimport { FilterFile, loader } from \"../../helper/index.js\";\nimport AV from \"./av.js\";\n\nexport default class Audio extends AV {\n  constructor(...audios: Buffer[]) {\n    super(...audios);\n  }\n\n  /**\n   * get avs of this instance\n   *\n   * @example\n   * ```js\n   *  const buffer = await Audio.loadFile(\"av.mp3\")\n   *\n   *  // not the same reference\n   *  const avs = new Audio(buffer).getAudios()\n   *  // => Buffer[]\n   * ```\n   */\n  getAudios() {\n    return [...this.avs];\n  }\n\n  /**\n   * set audios\n   *\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const audio = await Audio.fromFile(\"audio.mp3\")\n   *\n   *  // this method filter invalid audios before set\n   *  const newLength = await audio.setAudios(\\* async *\\(audio, index) => {\n   *    return index % 2 ? audio : audio.toString()\n   *  })\n   *  // => 0\n   * ```\n   */\n  async setAudios<T>(callback: AVSetCallback<T>) {\n    const audios = await Promise.all(this.avs.map(async (audio, index) => callback(audio, index)));\n    const filteredAudios = audios.filter((audio) => Buffer.isBuffer(audio) && audio.length > 0) as Buffer[];\n    const validAudios = await Audio.filter(...filteredAudios);\n    this.avs = validAudios;\n    return this.length;\n  }\n\n  /**\n   *\n   * @param audios - new audios (Buffer) to append the exists list\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const audio = new Audio()\n   *  const buffer1 = await Audio.loadFile(\"audio1.mp3\")\n   *  const buffer2 = await Audio.loadFile(\"audio2.mp3\")\n   *\n   *  // filter invalid audios\n   *  await audio.append(buffer1, Buffer.alloc(1), buffer2)\n   *  // => 2\n   * ```\n   */\n  override async append(...audios: Buffer[]) {\n    const filteredAudios = await Audio.filter(...audios);\n    this.avs.push(...filteredAudios);\n    return this.length;\n  }\n\n  /**\n   *\n   * @param audios - extend audios from instance to an another\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const buffer1 = await Audio.loadFile(\"audio1.mp3\")\n   *  const buffer2 = await Audio.loadFile(\"audio2.mp3\")\n   *  const audio1 = new Audio(buffer1, buffer2)\n   *\n   *  const audio2 = new Audio()\n   *\n   *  // don't apply any filters\n   *  audio2.extend(audio1)\n   *  // => 2\n   * ```\n   */\n  override extend(...audios: Audio[]) {\n    audios.forEach((audio) => {\n      this.avs.push(...audio.getAudios());\n    });\n    return this.length;\n  }\n\n  /**\n   *\n   * @returns - clone current instance\n   *\n   * @example\n   * ```js\n   *  const audio = new Audio()\n   *\n   *  // not the same reference\n   *  const clone = audio.clone()\n   *  // => Audio\n   * ```\n   */\n  override clone() {\n    return new Audio(...this.avs);\n  }\n\n  /**\n   * filter audios\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const audio = new Audio(Buffer.alloc(1))\n   *  await audio.filter()\n   *  // => 0\n   * ```\n   */\n  override async filter() {\n    this.avs = await Audio.filter(...this.avs);\n    return this.length;\n  }\n\n  /**\n   *\n   * @returns - filter non audio\n   *\n   * @example\n   * ```js\n   *  const audio1 = await Audio.loadFile(\"audio1.mp3\")\n   *  const audio2 = await Audio.loadFile(\"audio2.mp3\")\n   *\n   *  const buffer = await Audio.filter(audio1, audio2)\n   *  // => Buffer[]\n   * ```\n   */\n  static filter(...audios: Buffer[]) {\n    return new FilterFile(...audios).audio();\n  }\n\n  /**\n   * @throws\n   *\n   * load audios from files\n   * @returns - loaded files\n   *\n   * @example\n   * ```js\n   *  const audio = await Audio.fromFile(\"audio.mp3\")\n   *  // => Audio\n   *\n   *  const audio = await Audio.fromFile(\"audio.mp3\", \"text.txt\")\n   *  // => Audio\n   *  const length = audio.length\n   *  // => 1\n   *\n   *  const text = await Audio.fromFile(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromFile(...path: string[]) {\n    const buffer = await loader.loadFile(path);\n    return Audio.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * load audios from urls\n   * @returns - loaded urls\n   *\n   * @example\n   * ```js\n   *  const audio = await Audio.fromUrl(\"http://example.com/audio.mp3\")\n   *  // => Audio\n   *\n   *  const audio = await Audio.fromUrl(\"http://example.com/audio.mp3\", \"http://example.com/text.txt\")\n   *  // => Audio\n   *  const length = audio.length\n   *  // => 1\n   *\n   *  const text = await Audio.fromUrl(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await loader.loadUrl(url);\n    return Audio.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * @param audios - audios buffer\n   * @returns - create new safe instance\n   *\n   * @example\n   * ```js\n   *  const audio = await Audio.new(Buffer.alloc(1))\n   *  // => Error (throw)\n   *\n   *  const audioFile = await Audio.loadFile(\"audio.mp3\")\n   *\n   *  // filter non audio\n   *  const audio = await Audio.new(audioFile, Buffer.alloc(1))\n   *  // => Audio\n   *  const length = audio.length\n   *  // => 1\n   * ```\n   */\n  static async new(audios: Buffer[]) {\n    const filtered = await Audio.filter(...audios);\n    if (filtered.length === 0) throw new Error(`${Audio.name}: Non valid audio`);\n    return new Audio(...filtered);\n  }\n\n  /**\n   * check if an object is instance of Audio or not\n   * @returns - boolean\n   *\n   * @example\n   * ```js\n   *  const audio = new Audio()\n   *  const isAudio = Audio.isAudio(audio)\n   *  // => true\n   *\n   *  const object = new Object()\n   *  const isNotAudio = Audio.isAudio(object)\n   *  // => false\n   * ```\n   */\n  static isAudio(obj: unknown): obj is Audio {\n    return obj instanceof Audio;\n  }\n}\n", "import type { AVSetCallback } from \"../../types/index.js\";\nimport { FilterFile, loader, TmpFile } from \"../../helper/index.js\";\nimport path from \"node:path\";\nimport type { FfprobeData } from \"fluent-ffmpeg\";\nimport AV from \"./av.js\";\n\nexport default class Video extends AV {\n  constructor(...videos: Buffer[]) {\n    super(...videos);\n  }\n\n  /**\n   * get videos of this instance\n   *\n   * @example\n   * ```js\n   *  const buffer = await Video.loadFile(\"video.mp4\")\n   *\n   *  // not the same reference\n   *  const videos = new Video(buffer).getVideos()\n   *  // => Buffer[]\n   * ```\n   */\n  getVideos() {\n    return [...this.avs];\n  }\n\n  /**\n   * set videos\n   *\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const video = await Video.fromFile(\"video.mp4\")\n   *\n   *  // this method filter invalid videos before set\n   *  const newLength = await video.setVideos(\\* async *\\(video, index) => {\n   *    return index % 2 ? video : video.toString()\n   *  })\n   *  // => 0\n   * ```\n   */\n  async setVideos<T>(callback: AVSetCallback<T>) {\n    const videos = await Promise.all(this.avs.map(async (video, index) => callback(video, index)));\n    const filteredVideos = videos.filter((video) => Buffer.isBuffer(video) && video.length > 0) as Buffer[];\n    const validVideos = await Video.filter(...filteredVideos);\n    this.avs = validVideos;\n    return this.length;\n  }\n\n  /**\n   *\n   * @param videos - new videos (Buffer) to append the exists list\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const video = new Video()\n   *  const buffer1 = await Video.loadFile(\"video1.mp4\")\n   *  const buffer2 = await Video.loadFile(\"video2.mp4\")\n   *\n   *  // filter invalid videos\n   *  await video.append(buffer1, Buffer.alloc(1), buffer2)\n   *  // => 2\n   * ```\n   */\n  override async append(...videos: Buffer[]) {\n    const filteredVideos = await Video.filter(...videos);\n    this.avs.push(...filteredVideos);\n    return this.length;\n  }\n\n  /**\n   *\n   * @param videos - extend videos from instance to an another\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const buffer1 = await Video.loadFile(\"video1.mp4\")\n   *  const buffer2 = await Video.loadFile(\"video2.mp4\")\n   *  const video1 = new Video(buffer1, buffer2)\n   *\n   *  const video2 = new Video()\n   *\n   *  // don't apply any filters\n   *  video2.extend(video1)\n   *  // => 2\n   * ```\n   */\n  override extend(...videos: Video[]) {\n    videos.forEach((video) => {\n      this.avs.push(...video.getVideos());\n    });\n    return this.length;\n  }\n\n  /**\n   *\n   * @returns - clone current instance\n   *\n   * @example\n   * ```js\n   *  const video = new Video()\n   *\n   *  // not the same reference\n   *  const clone = video.clone()\n   *  // => Video\n   * ```\n   */\n  override clone() {\n    return new Video(...this.avs);\n  }\n\n  /**\n   * filter videos\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const video = new Video(Buffer.alloc(1))\n   *  await video.filter()\n   *  // => 0\n   * ```\n   */\n  override async filter() {\n    this.avs = await Video.filter(...this.avs);\n    return this.length;\n  }\n\n  /**\n   * Remove audio from video\n   * @returns muted videos\n   *\n   * @example\n   * ```js\n   *  const video = await Video.fromFile(\"video.mp4\")\n   *  const videos = await video.only()\n   *  // => Buffer[]\n   * ```\n   */\n  async only() {\n    return this.custom(async (command, tmpFile, index) => {\n      const format = (await FilterFile.extension(this.avs[index]!)) ?? \"\";\n      if (format.length === 0) throw new Error(`${Video.name}: Unknown video format`);\n\n      const output = path.join(tmpFile.tmp!.path, TmpFile.generateFileName(format));\n\n      return new Promise<Buffer>((resolve, reject) => {\n        command\n          .noAudio()\n          .on(\"end\", () => {\n            loader.loadFile(output).then(resolve, reject);\n          })\n          .on(\"error\", reject)\n          .output(output)\n          .run();\n      });\n    });\n  }\n\n  /**\n   * Extract audio from video\n   * @param format audio format\n   * @returns audio buffer\n   *\n   * @example\n   * ```js\n   *  const video = await Video.fromFile(\"video.mp4\")\n   *  const audios = await video.audio(\"mp3\")\n   *  // => (Buffer | null)[]\n   * ```\n   */\n  async audio(format: string) {\n    const metadatas = await this.metadata();\n    return this.custom(async (command, tmpFile, index) => {\n      const metadata = metadatas[index]!;\n      const audioStream = metadata.streams.find((stream) => stream.codec_type === \"audio\");\n      if (typeof audioStream === \"undefined\") return null;\n\n      const output = path.join(tmpFile.tmp!.path, TmpFile.generateFileName(format));\n\n      return new Promise<Buffer>((resolve, reject) => {\n        command\n          .noVideo()\n          .toFormat(format)\n          .on(\"end\", () => {\n            loader.loadFile(output).then(resolve, reject);\n          })\n          .on(\"error\", reject)\n          .output(output)\n          .run();\n      });\n    });\n  }\n\n  /**\n   * take screenshots from video\n   * @param timemarks where we take screenshot (seconds)\n   * @returns image in png format\n   *\n   * @example\n   * ```js\n   *  //Video length: 10 seconds\n   *  const video = await Video.fromFile(\"video.mp4\")\n   *  const images = await video.screenshot([0, 1, 2, 3])\n   *  // => Buffer[][]\n   * ```\n   */\n  async screenshot(timemarks: number[] | string[]) {\n    return this.custom(async (command, tmpFile) => {\n      let imagesPath: string[] = [];\n\n      return new Promise<Buffer[]>((resolve, reject) => {\n        command\n          .screenshot({ filename: \"frame.png\", timemarks }, tmpFile.tmp!.path)\n          .on(\"filenames\", (filenames: string[]) => {\n            imagesPath = filenames.map((filename) => path.join(tmpFile.tmp!.path, filename));\n          })\n          .on(\"end\", () => {\n            loader.loadFile(imagesPath).then(resolve, reject);\n          })\n          .on(\"error\", reject);\n      });\n    });\n  }\n\n  /**\n   *\n   * @returns - filter non video\n   *\n   * @example\n   * ```js\n   *  const video1 = await Video.loadFile(\"video1.mp4\")\n   *  const video2 = await Video.loadFile(\"video2.mp4\")\n   *\n   *  const buffer = await Video.filter(video1, video2)\n   *  // => Buffer[]\n   * ```\n   */\n  static async filter(...videos: Buffer[]) {\n    return new FilterFile(...videos).video();\n  }\n\n  /**\n   * @throws\n   *\n   * load videos from files\n   * @returns - loaded files\n   *\n   * @example\n   * ```js\n   *  const video = await Video.fromFile(\"video.mp4\")\n   *  // => Video\n   *\n   *  const video = await Video.fromFile(\"video.mp4\", \"text.txt\")\n   *  // => Video\n   *  const length = video.length\n   *  // => 1\n   *\n   *  const text = await Video.fromFile(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromFile(...path: string[]) {\n    const buffer = await loader.loadFile(path);\n    return Video.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * load videos from urls\n   * @returns - loaded urls\n   *\n   * @example\n   * ```js\n   *  const video = await Video.fromUrl(\"http://example.com/video.mp4\")\n   *  // => Video\n   *\n   *  const video = await Video.fromUrl(\"http://example.com/video.mp4\", \"http://example.com/text.txt\")\n   *  // => Video\n   *  const length = video.length\n   *  // => 1\n   *\n   *  const text = await Video.fromUrl(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await loader.loadUrl(url);\n    return Video.new(buffer);\n  }\n\n  /**\n   * generate timemarks to take video screenshots\n   *\n   * @param metadata video metadata\n   * @param interval interval between each timemark (seconds)\n   *\n   * @example\n   * ```js\n   *  // Video length: 10 seconds\n   *  const video = await Video.fromFile(\"video.mp4\")\n   *  const metadata = await video.metadata()\n   *  const timemarks = Video.generateTimemarks(metadata[0], 2)\n   *  // => [0, 2, 4, 6, 8, 10]\n   * ```\n   */\n  static async generateTimemarks<T extends FfprobeData>(metadata: T, interval: number): Promise<number[]>;\n  static async generateTimemarks<T extends FfprobeData[]>(metadata: T, interval: number): Promise<number[][]>;\n  static async generateTimemarks<T extends FfprobeData | FfprobeData[]>(metadata: T, interval = 1) {\n    if (Array.isArray(metadata)) return Promise.all(metadata.map((mt) => Video.generateTimemarks(mt, interval)));\n\n    const timemarks: number[] = [];\n    const duration = metadata.format.duration ?? 0;\n    for (let i = 0; i < duration; i += interval) timemarks.push(i);\n    return timemarks;\n  }\n\n  /**\n   * @throws\n   *\n   * @param videos - videos buffer\n   * @returns - create new safe instance\n   *\n   * @example\n   * ```js\n   *  const video = await Video.new(Buffer.alloc(1))\n   *  // => Error (throw)\n   *\n   *  const videoFile = await Video.loadFile(\"video.mp3\")\n   *\n   *  // filter non video\n   *  const video = await Video.new(videoFile, Buffer.alloc(1))\n   *  // => Video\n   *  const length = video.length\n   *  // => 1\n   * ```\n   */\n  static async new(videos: Buffer[]) {\n    const filtered = await Video.filter(...videos);\n    if (filtered.length === 0) throw new Error(`${Video.name}: Non valid video`);\n    return new Video(...filtered);\n  }\n\n  /**\n   * check if an object is instance of Video or not\n   * @returns - boolean\n   *\n   * @example\n   * ```js\n   *  const video = new Video()\n   *  const isVideo = Video.isVideo(video)\n   *  // => true\n   *\n   *  const object = new Object()\n   *  const isNotVideo = Video.isVideo(object)\n   *  // => false\n   * ```\n   */\n  static isVideo(obj: unknown): obj is Video {\n    return obj instanceof Video;\n  }\n}\n", "import { Image, Text, PDF, CSV, Video, Audio } from \"./core/index.js\";\n\nexport default class Processor {\n  private readonly files: Buffer[];\n\n  constructor(...files: Buffer[]) {\n    this.files = files;\n  }\n\n  image() {\n    return Image.new(this.files);\n  }\n\n  pdf() {\n    return PDF.new(this.files);\n  }\n\n  csv() {\n    return CSV.new(this.files);\n  }\n\n  text() {\n    return Text.new(this.files);\n  }\n\n  video() {\n    return Video.new(this.files);\n  }\n\n  audio() {\n    return Audio.new(this.files);\n  }\n}\n"],
  "mappings": "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",
  "names": ["core_exports", "__export", "Audio", "CSV", "Image", "PDF", "PDF_experimental", "Text", "Video", "helper_exports", "__export", "FilterFile", "TmpFile", "isArrayOfBuffer", "isArrayOfString", "isUrl", "loader_exports", "parser_exports", "Mutex", "isFile", "isFileNode", "parser_exports", "__export", "toBase64", "toBuffer", "toFile", "toReadable", "isAnyArrayBuffer", "isUint8Array", "Readable", "fs", "isArrayOfBuffer", "array", "arr", "isArrayOfString", "isUrl", "value", "error", "any2buffer", "array2buffer", "buffer2readable", "isReadable", "isReadableStream", "isStream", "readable2buffer", "readablestream2buffer", "stream2buffer", "string2buffer", "uint8array2buffer", "isBase64", "loader_exports", "__export", "loadDir", "loadFile", "loadGlob", "loadUrl", "fs", "path", "fastGlob", "url2buffer", "loadFile", "paths", "__async", "path", "fs", "loadDir", "files", "file", "loadGlob", "globs", "options", "_a", "cwd", "entries", "fastGlob", "entry", "fullPath", "stat", "result", "loadUrl", "urls", "url", "url2buffer", "toBuffer", "input", "__async", "i", "isUrl", "loadUrl", "isUint8Array", "uint8array2buffer", "isAnyArrayBuffer", "array2buffer", "isStream", "stream2buffer", "isReadableStream", "readablestream2buffer", "isReadable", "Readable", "readable2buffer", "fs", "loadFile", "isBase64", "string2buffer", "any2buffer", "toReadable", "buffer", "buffer2readable", "toBase64", "encoding", "toFile", "file", "f", "FilterFile", "_FilterFile", "input", "__async", "applications", "audios", "fonts", "images", "models", "texts", "videos", "me", "buffer", "toBuffer", "isFile", "file", "mutexes", "Mutex", "files", "release", "isFileNode", "type", "writeFile", "randomUUID", "path", "dir", "TmpFile", "_TmpFile", "files", "file", "__async", "_a", "ext", "FilterFile", "fileName", "fullPath", "path", "writeFile", "options", "dir", "__spreadValues", "randomUUID", "fs", "path", "fastGlob", "createWorker", "sharp", "Readable", "isAnyArrayBuffer", "isUint8Array", "fs", "path", "any2buffer", "array2buffer", "buffer2readable", "isReadable", "isReadableStream", "isStream", "readable2buffer", "readablestream2buffer", "stream2buffer", "string2buffer", "uint8array2buffer", "url2buffer", "isBase64", "fastGlob", "puppeteer", "Core", "_Core", "readable", "writable", "options", "puppeteer", "paths", "__async", "path", "fs", "files", "file", "globs", "_a", "entries", "fastGlob", "cwd", "entry", "fullPath", "stat", "result", "urls", "url", "url2buffer", "input", "i", "isUrl", "isUint8Array", "uint8array2buffer", "isAnyArrayBuffer", "array2buffer", "isStream", "stream2buffer", "isReadableStream", "readablestream2buffer", "isReadable", "Readable", "readable2buffer", "isBase64", "string2buffer", "any2buffer", "buffer", "buffer2readable", "encoding", "f", "Image", "_Image", "Core", "images", "callback", "__async", "filteredImages", "image", "index", "validImages", "sharp", "_0", "logo", "options", "resize", "gravity", "alpha", "tile", "blend", "premultiplied", "buffer", "parser_exports", "input", "format", "langs", "worker", "createWorker", "recs", "cwd", "traineddata", "fastGlob", "data", "fs", "path", "rec", "FilterFile", "rtn", "r", "urls", "url", "browser", "page", "res", "loader_exports", "filtered", "obj", "zlib", "crypto", "Text", "_Text", "Core", "texts", "crypto", "callback", "__async", "filteredTexts", "text", "index", "map", "string", "str", "code", "method", "options", "reads", "parser_exports", "algorithm", "key", "hmacKey", "_0", "_1", "iv", "cipher", "decipher", "array", "gzipFn", "deflateFn", "deflateRawFn", "brotliCompressFn", "gunzipFn", "inflateFn", "inflateRawFn", "brotliDecompressFn", "unzipFn", "FilterFile", "path", "buffer", "loader_exports", "url", "filtered", "obj", "resolve", "reject", "zlib", "err", "buf", "readable", "gzip", "deflate", "deflateRaw", "brotliCompress", "gunzip", "inflate", "inflateRaw", "brotliDecompress", "unzip", "csv", "csvSync", "CSV", "_CSV", "Core", "csvs", "callback", "__async", "filteredCsvs", "csv", "index", "options", "_a", "_b", "parse", "c", "parsed", "handler", "p", "parser_exports", "FilterFile", "path", "buffer", "loader_exports", "url", "filtered", "obj", "resolve", "reject", "err", "records", "_0", "input", "_1", "str", "readable", "PageSizes", "PDFDocument", "PDF", "_PDF", "Core", "pdfs", "callback", "__async", "filteredPdfs", "pdf", "index", "validPdfs", "options", "document", "merge", "copied", "page", "documents", "path", "buffer", "loader_exports", "url", "_0", "images", "_a", "_b", "image", "isPNG", "isJPG", "FilterFile", "pageSize", "PageSizes", "scaleImage", "position", "PDFDocument", "pageDimensions", "pdfImage", "imageDimensions", "htmls", "html", "browser", "res", "save", "parser_exports", "filtered", "obj", "mupdf", "PDF_experimental", "_PDF_experimental", "pdfs", "__async", "document", "texts", "countPages", "i", "page", "images", "_a", "pageImages", "_bbox", "_transform", "image", "png", "buffer", "Core", "annots", "links", "pageLinks", "link", "widget", "s", "callback", "pdf", "index", "ffmpeg", "ffmpegPath", "ffprobePath", "path", "AV", "_AV", "Core", "avs", "__async", "command", "resolve", "reject", "err", "metadata", "format", "tmpFile", "output", "path", "TmpFile", "loader_exports", "duration", "start", "index", "_a", "_b", "avDuration", "error", "FilterFile", "avPath", "chunks", "i", "validDuration", "chunk", "fps", "converted", "merged", "av", "commandLine", "callback", "result", "options", "ffmpeg", "ffmpegPath", "ffprobePath", "Audio", "_Audio", "AV", "audios", "callback", "__async", "filteredAudios", "audio", "index", "validAudios", "FilterFile", "path", "buffer", "loader_exports", "url", "filtered", "obj", "path", "Video", "_Video", "AV", "videos", "callback", "__async", "filteredVideos", "video", "index", "validVideos", "command", "tmpFile", "_a", "format", "FilterFile", "output", "path", "TmpFile", "resolve", "reject", "loader_exports", "metadatas", "stream", "timemarks", "imagesPath", "filenames", "filename", "buffer", "url", "metadata", "interval", "mt", "duration", "i", "filtered", "obj", "Processor", "files", "Image", "PDF", "CSV", "Text", "Video", "Audio"]
}
