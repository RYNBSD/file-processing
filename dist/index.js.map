{
  "version": 3,
  "sources": ["../src/core/index.ts", "../src/helper/index.ts", "../src/helper/filter.ts", "../src/core/core.ts", "../src/helper/tmp.ts", "../src/helper/fn.ts", "../src/core/image.ts", "../src/core/text.ts", "../src/core/pdf.ts", "../src/core/csv.ts", "../src/core/av/av.ts", "../src/core/av/audio.ts", "../src/core/av/video.ts", "../src/processor.ts"],
  "sourcesContent": ["export { default as Image } from \"./image.js\";\nexport { default as Text } from \"./text.js\";\nexport { default as PDF } from \"./pdf.js\";\nexport { default as CSV } from \"./csv.js\";\nexport * from \"./av/index.js\";\n", "export { default as FilterFile } from \"./filter.js\";\nexport { default as TmpFile } from \"./tmp.js\";\nexport * from \"./fn.js\";\n", "import type { InputFiles } from \"../types/index.js\";\nimport { Mutex } from \"async-mutex\";\nimport isFile from \"@ryn-bsd/is-file\";\nimport Core from \"../core/core.js\";\n\n/**\n * Easy and fast way to filter bunche of files\n */\nexport default class FilterFile {\n  private readonly input: InputFiles[];\n\n  constructor(...input: InputFiles[]) {\n    this.input = input;\n  }\n\n  async application() {\n    const { applications } = await FilterFile.filter(...this.input);\n    return applications;\n  }\n\n  async audio() {\n    const { audios } = await FilterFile.filter(...this.input);\n    return audios;\n  }\n\n  async font() {\n    const { fonts } = await FilterFile.filter(...this.input);\n    return fonts;\n  }\n\n  async image() {\n    const { images } = await FilterFile.filter(...this.input);\n    return images;\n  }\n\n  async model() {\n    const { models } = await FilterFile.filter(...this.input);\n    return models;\n  }\n\n  async text() {\n    const { texts } = await FilterFile.filter(...this.input);\n    return texts;\n  }\n\n  async video() {\n    const { videos } = await FilterFile.filter(...this.input);\n    return videos;\n  }\n\n  /**\n   * Filter custom file\n   * @param me - mime extension\n   */\n  async custom(me: string) {\n    const buffer = await Core.toBuffer(this.input);\n    const result = await isFile.isCustom(buffer, me);\n    return result.filter((file) => file.valid).map((file) => file.value) as Buffer[];\n  }\n\n  static async filter(...input: InputFiles[]) {\n    const buffer = await Core.toBuffer(input);\n\n    const mutexes = {\n      applications: new Mutex(),\n      audios: new Mutex(),\n      fonts: new Mutex(),\n      images: new Mutex(),\n      models: new Mutex(),\n      texts: new Mutex(),\n      videos: new Mutex(),\n    };\n\n    const files: Record<keyof typeof mutexes, Buffer[]> = {\n      applications: [],\n      audios: [],\n      fonts: [],\n      images: [],\n      models: [],\n      texts: [],\n      videos: [],\n    };\n\n    await Promise.all(\n      buffer.map(async (buffer) => {\n        if (await isFile.isApplication(buffer)) {\n          const release = await mutexes.applications.acquire();\n          files.applications.push(buffer);\n          release();\n        } else if (await isFile.isAudio(buffer)) {\n          const release = await mutexes.audios.acquire();\n          files.audios.push(buffer);\n          release();\n        } else if (await isFile.isFont(buffer)) {\n          const release = await mutexes.fonts.acquire();\n          files.fonts.push(buffer);\n          release();\n        } else if (await isFile.isImage(buffer)) {\n          const release = await mutexes.images.acquire();\n          files.images.push(buffer);\n          release();\n        } else if (await isFile.isModel(buffer)) {\n          const release = await mutexes.models.acquire();\n          files.models.push(buffer);\n          release();\n        } else if (await isFile.isText(buffer)) {\n          const release = await mutexes.texts.acquire();\n          files.texts.push(buffer);\n          release();\n        } else if (await isFile.isVideo(buffer)) {\n          const release = await mutexes.videos.acquire();\n          files.videos.push(buffer);\n          release();\n        }\n      }),\n    );\n\n    return files;\n  }\n}\n", "import type { InputFiles } from \"../types/index.js\";\nimport { Readable, type Writable } from \"node:stream\";\nimport { isAnyArrayBuffer, isUint8Array } from \"node:util/types\";\nimport { readFile, writeFile, stat as fsStat, readdir } from \"node:fs/promises\";\nimport path from \"node:path\";\nimport {\n  any2buffer,\n  array2buffer,\n  buffer2readable,\n  isReadable,\n  isReadableStream,\n  isStream,\n  readable2buffer,\n  readablestream2buffer,\n  stream2buffer,\n  string2buffer,\n  uint8array2buffer,\n  url2buffer,\n} from \"@ryn-bsd/from-buffer-to\";\nimport isBase64 from \"is-base64\";\nimport { default as fastGlob } from \"fast-glob\";\nimport puppeteer from \"puppeteer\";\nimport { isUrl } from \"../helper/index.js\";\n\nexport default abstract class Core {\n  constructor() {}\n\n  abstract get length(): number;\n\n  abstract append(...buffers: Buffer[]): Promise<number>;\n  abstract extend(...cors: unknown[]): number;\n  abstract clone(): Core;\n\n  abstract filter(): Promise<number>;\n  abstract metadata(): Promise<unknown>;\n\n  // abstract stream(): Promise<void>;\n\n  /**\n   * @param readable - input\n   * @param writable - output or middleware\n   *\n   * @example\n   * ```js\n   *  const writable = Core.stream(readable, transform)\n   *  // => Writable\n   *\n   *  writable.pipe(output)\n   * ```\n   */\n  static stream(readable: Readable, writable: Writable) {\n    return readable.pipe(writable);\n  }\n\n  static initBrowser(options?: puppeteer.PuppeteerLaunchOptions) {\n    return puppeteer.launch(options);\n  }\n\n  /**\n   *  @param paths - file/files path\n   *\n   * @example\n   * ```js\n   *  const files = Core.loadFile([\"/file.txt\", \"/image.png\"])\n   *  // => Buffer[]\n   *\n   *  const file = Core.loadFile(\"/file.txt\")\n   *  // => Buffer\n   * ```\n   */\n  static async loadFile<T extends string>(paths: T): Promise<Buffer>;\n  static async loadFile<T extends string[]>(paths: T): Promise<Buffer[]>;\n  static async loadFile<T extends string | string>(paths: T) {\n    if (Array.isArray(paths)) return Promise.all(paths.map((path) => Core.loadFile(path)));\n    return readFile(paths);\n  }\n\n  /**\n   *  @param paths - directory/directories path\n   *\n   * @example\n   * ```js\n   *  const files = Core.loadDir([\"/dir1\", \"/dir2\"])\n   *  // => Buffer[][]\n   *\n   *  const file = Core.loadDir(\"/dir\")\n   *  // => Buffer[]\n   * ```\n   */\n  static async loadDir<T extends string>(paths: T): Promise<Buffer[]>;\n  static async loadDir<T extends string[]>(paths: T): Promise<Buffer[][]>;\n  static async loadDir<T extends string | string[]>(paths: T) {\n    if (Array.isArray(paths)) return Promise.all(paths.map((path) => Core.loadDir(path)));\n    const files = await readdir(paths);\n    return Core.loadFile(files.map((file) => path.join(paths, file)));\n  }\n\n  /**\n   * @example\n   * ```js\n   *  Core.loadGlob(\"/*.txt\")\n   *  // => (Buffer | Buffer[])[]\n   *\n   *  Core.loadGlob([\"/*.txt\", \"/images\"])\n   *  // => (Buffer | Buffer[])[]\n   * ```\n   */\n  static async loadGlob<T extends fastGlob.Pattern | fastGlob.Pattern[]>(\n    globs: T,\n    options?: fastGlob.Options,\n  ): Promise<(Buffer | Buffer[])[]> {\n    const entries = await fastGlob(globs, options);\n    const cwd = options?.cwd ?? process.cwd();\n\n    const results = await Promise.all(\n      entries.map(async (entry) => {\n        const fullPath = path.join(cwd, entry);\n        const stat = await fsStat(fullPath);\n\n        if (stat.isFile()) return Core.loadFile(fullPath);\n        else if (stat.isDirectory()) return Core.loadDir(fullPath);\n        return null;\n      }),\n    );\n\n    return results.filter((result) => result !== null) as (Buffer | Buffer[])[];\n  }\n\n  /**\n   *  @param urls - file/files url\n   *\n   * @example\n   * ```js\n   *  const files = Core.loadUrl([\"https://example.com/file.text\", \"https://example.com/image.png\"])\n   *  // => Buffer[]\n   *\n   *  const file = Core.loadUrl(\"https://example.com/file.text\")\n   *  // => Buffer\n   * ```\n   */\n  static async loadUrl<T extends string | URL>(urls: T): Promise<Buffer>;\n  static async loadUrl<T extends string[] | URL[]>(urls: T): Promise<Buffer[]>;\n  static async loadUrl<T extends string | URL | string[] | URL[]>(urls: T) {\n    if (Array.isArray(urls)) return Promise.all(urls.map((url) => Core.loadUrl(url)));\n    return url2buffer(urls);\n  }\n\n  /**\n   * @param input - any type of supported inputs\n   *\n   * @example\n   * ```js\n   *  Core.toBuffer(\"cnluYnNk\")\n   *  Core.toBuffer(\"/file.text\")\n   *  Core.toBuffer(\"https://example.com/file.text\")\n   * ```\n   */\n  static async toBuffer<T extends InputFiles>(input: T): Promise<Buffer>;\n  static async toBuffer<T extends InputFiles[]>(input: T): Promise<Buffer[]>;\n  static async toBuffer<T extends InputFiles | InputFiles[]>(input: T) {\n    if (Array.isArray(input)) return Promise.all(input.map((i) => Core.toBuffer(i)));\n\n    if (Buffer.isBuffer(input)) return input;\n    else if (isUrl(input)) return Core.loadUrl(input);\n    else if (isUint8Array(input)) return uint8array2buffer(input);\n    else if (isAnyArrayBuffer(input)) return array2buffer(input);\n    else if (isStream(input)) return stream2buffer(input);\n    else if (isReadableStream(input)) return readablestream2buffer(input);\n    else if (isReadable(input) && Readable.isReadable(input)) return readable2buffer(input);\n    else if (typeof input === \"string\") {\n      const fileStat = await fsStat(input);\n      if (fileStat.isFile()) return Core.loadFile(input);\n      else if (isBase64(input, { allowEmpty: false })) return Buffer.from(input, \"base64\");\n      return string2buffer(input, false);\n    }\n    return any2buffer(input);\n  }\n\n  /**\n   * Convert any type of inputs to Readable\n   *\n   * @example\n   * ```js\n   *  Core.toReadable(\"cnluYnNk\")\n   *  Core.toReadable(\"/file.text\")\n   *  Core.toReadable(\"https://example.com/file.text\")\n   * ```\n   */\n  static async toReadable<T extends InputFiles>(input: T): Promise<Readable>;\n  static async toReadable<T extends InputFiles[]>(input: T): Promise<Readable[]>;\n  static async toReadable<T extends InputFiles | InputFiles[]>(input: T) {\n    if (Array.isArray(input)) return Promise.all(input.map((i) => Core.toReadable(i)));\n    if (isReadable(input) && Readable.isReadable(input)) return input;\n    const buffer = await Core.toBuffer(input);\n    return buffer2readable(buffer);\n  }\n\n  /**\n   * Convert any type of inputs into base64 | base64url\n   *\n   * @example\n   * ```js\n   *  Core.toBase64(\"cnluYnNk\")\n   *  Core.toBase64(\"/file.text\")\n   *  Core.toBase64(\"https://example.com/file.text\")\n   * ```\n   */\n  static async toBase64<T extends InputFiles>(input: T, encoding?: \"base64\" | \"base64url\"): Promise<string>;\n  static async toBase64<T extends InputFiles[]>(input: T, encoding?: \"base64\" | \"base64url\"): Promise<string[]>;\n  static async toBase64<T extends InputFiles | InputFiles[]>(input: T, encoding: \"base64\" | \"base64url\" = \"base64\") {\n    if (Array.isArray(input)) return Promise.all(input.map((i) => Core.toBase64(i)));\n    if (typeof input === \"string\" && isBase64(input)) return input;\n    const buffer = await Core.toBuffer(input);\n    return buffer.toString(encoding);\n  }\n\n  /**\n   * Save any type of inputs into file\n   *\n   * @example\n   * ```js\n   *  Core.toFile(\n   *    [\n   *      {\n   *        path: \"where-to-store.txt\",\n   *        input: Buffer.alloc(1)\n   *      }\n   *    ]\n   *  )\n   * ```\n   */\n  static async toFile(file: { path: string; input: InputFiles }[]) {\n    await Promise.all(\n      file.map(async (f) => {\n        const buffer = await Core.toBuffer(f.input);\n        return writeFile(f.path, buffer);\n      }),\n    );\n  }\n}\n", "import type { DirOptions } from \"tmp\";\nimport { writeFile } from \"node:fs/promises\";\nimport { randomUUID } from \"node:crypto\";\nimport path from \"node:path\";\nimport { dir, type DirectoryResult } from \"tmp-promise\";\nimport { Node as isFileNode } from \"@ryn-bsd/is-file\";\n\n/**\n * Create a tmp dir store your files manipulate them and then clean.\n */\nexport default class TmpFile {\n  private readonly files: Buffer[];\n\n  public readonly paths: string[] = [];\n  public tmp?: DirectoryResult;\n\n  constructor(...files: Buffer[]) {\n    this.files = files;\n  }\n\n  private async createFn(file: Buffer) {\n    const ext = (await isFileNode.type(file))?.ext ?? \"\";\n    if (ext.length === 0) throw new Error(`${TmpFile.name}: Unknown file when create`);\n\n    const fileName = TmpFile.generateFileName(ext);\n    const fullPath = path.join(this.tmp!.path, fileName);\n\n    await writeFile(fullPath, file);\n    this.paths.push(fullPath);\n  }\n\n  private async create() {\n    await Promise.all(this.files.map(this.createFn.bind(this)));\n  }\n\n  async init(options?: DirOptions) {\n    this.tmp = await dir({ unsafeCleanup: true, ...options });\n    await this.create();\n    return this as Omit<TmpFile, \"init\">;\n  }\n\n  async clean() {\n    await this.tmp!.cleanup();\n    this.paths.splice(0, this.paths.length);\n  }\n\n  static generateFileName(ext: string) {\n    return `${randomUUID()}_${Date.now()}.${ext}`;\n  }\n}\n", "import type { InputFiles } from \"../types/index.js\";\nimport { readFile } from \"node:fs/promises\";\nimport { isReadable, isStream, stream2buffer } from \"@ryn-bsd/from-buffer-to\";\nimport { isArrayBuffer, isSharedArrayBuffer, isUint8Array } from \"node:util/types\";\n\n/**\n * @deprecated\n * Call:\n * ```js\n *  Core.toBuffer();\n * ```\n */\nexport async function input2buffer(input: InputFiles) {\n  if (Buffer.isBuffer(input)) return input;\n  else if (typeof input === \"string\") return readFile(input);\n  else if (isReadable(input) || isStream(input)) return stream2buffer(input);\n  else if (isUint8Array(input) || isArrayBuffer(input) || isSharedArrayBuffer(input)) return Buffer.from(input);\n\n  return null;\n}\n\nexport function isArrayOfBuffer(array: unknown[]): array is Buffer[] {\n  if (!Array.isArray(array)) return false;\n  for (const arr of array) if (!Buffer.isBuffer(arr)) return false;\n  return true;\n}\n\nexport function isArrayOfString(array: unknown[]): array is string[] {\n  if (!Array.isArray(array)) return false;\n  for (const arr of array) if (typeof arr !== \"string\") return false;\n  return true;\n}\n\nexport function isUrl(value: unknown): value is URL {\n  if (typeof value !== \"string\") return false;\n\n  try {\n    new URL(value);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n", "import type { ScreenshotOptions } from \"puppeteer\";\nimport type {\n  ImageCustomCallback,\n  ImageFormats,\n  ImageOptions,\n  ImageSetCallback,\n  ImageWatermarkOptions,\n  InputFiles,\n} from \"../types/index.js\";\nimport { FilterFile } from \"../helper/index.js\";\nimport sharp from \"sharp\";\nimport Core from \"./core.js\";\n\nexport default class Image extends Core {\n  private images: Buffer[];\n\n  /**\n   * Create unsafe instance\n   *\n   * to create safe instance:\n   * ```js\n   *  const imageFile = await Image.loadFile(\"image.png\")\n   *\n   *  // create safe new instance\n   *  const image = Image.new(imageFile)\n   *  // => Image\n   * ```\n   */\n  constructor(...images: Buffer[]) {\n    super();\n    this.images = images;\n  }\n\n  /** get current length of images */\n  get length() {\n    return this.images.length;\n  }\n\n  /**\n   * get images of this instance\n   *\n   * @example\n   * ```js\n   *  const buffer = await Image.loadFile(\"image.png\")\n   *\n   *  // not the same reference\n   *  const images = new Image(buffer).getImages()\n   *  // => 1\n   * ```\n   */\n  getImages() {\n    return [...this.images];\n  }\n\n  /**\n   * set images\n   *\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const image = await Image.fromFile(\"image.png\")\n   *\n   *  // this method filter invalid images after set, the callback could be async\n   *  const newLength = await image.setImages((image, index) => {\n   *    return index % 2 ? image : image.toString()\n   *  })\n   *  // => 0\n   * ```\n   */\n  async setImages<T>(callback: ImageSetCallback<T>) {\n    const images = await Promise.all(this.images.map(async (image, index) => callback(image, index)));\n    const filteredImages = images.filter((image) => Buffer.isBuffer(image) && image.length > 0) as Buffer[];\n    const validImages = await Image.filter(...filteredImages);\n    this.images = validImages;\n    return this.length;\n  }\n\n  /**\n   *\n   * @param images - new images (Buffer) to append the exists list\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const image = new Image()\n   *  const buffer1 = await Image.loadFile(\"image1.png\")\n   *  const buffer2 = await Image.loadFile(\"image2.png\")\n   *\n   *  // filter invalid images\n   *  await image.append(buffer1, Buffer.alloc(1), buffer2)\n   *  // => 2\n   * ```\n   */\n  override async append(...images: Buffer[]) {\n    const filteredImages = await Image.filter(...images);\n    this.images.push(...filteredImages);\n    return this.length;\n  }\n\n  /**\n   *\n   * @param images - extend images from instance to another\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const buffer1 = await Image.loadFile(\"image1.png\")\n   *  const buffer2 = await Image.loadFile(\"image2.png\")\n   *  const image1 = new Image(buffer1, buffer2)\n   *\n   *  const image2 = new Image()\n   *\n   *  // don't apply any filters\n   *  image2.extend(image1)\n   *  // => 2\n   * ```\n   */\n  override extend(...images: Image[]) {\n    images.forEach((image) => {\n      this.images.push(...image.getImages());\n    });\n    return this.length;\n  }\n\n  /**\n   *\n   * @returns - clone current instance\n   *\n   * @example\n   * ```js\n   *  const image = new Image()\n   *\n   *  // not the same reference\n   *  const clone = image.clone()\n   *  // => Image\n   * ```\n   */\n  override clone() {\n    return new Image(...this.images);\n  }\n\n  /**\n   * filter images\n   * @returns - new length\n   *\n   * @example\n   * ```js\n   *  const image = new Image(Buffer.alloc(1))\n   *  await image.filter()\n   *  // => 0\n   * ```\n   */\n  override async filter() {\n    this.images = await Image.filter(...this.images);\n    return this.length;\n  }\n\n  /**\n   * @returns - images metadata\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const image = new Image(image1, image2)\n   *  const metadata = await image.metadata()\n   *  // => Metadata[]\n   * ```\n   * */\n  override async metadata() {\n    return Promise.all(this.images.map((image) => Image.newSharp(image).metadata()));\n  }\n\n  /**\n   * Add watermark to images\n   *\n   * const logo = \"logo.png\" // or any supported input type\n   *\n   * const image1 = await Image.loadFile(\"image1.png\")\n   * const image2 = await Image.loadFile(\"image2.png\")\n   * const image = new Image(image1, image2)\n   *\n   * const watermark = await image.watermark(logo)\n   * // => { data: Buffer; info: sharp.OutputInfo; }[]\n   */\n  async watermark(logo: InputFiles, options: ImageWatermarkOptions = {}) {\n    const { resize, gravity = \"center\", alpha = 0.5, tile = false, blend = \"over\", premultiplied } = options;\n\n    const buffer = await Core.toBuffer(logo);\n    const input = await Image.newSharp(buffer)\n      .resize(resize)\n      .ensureAlpha(alpha)\n      .composite([\n        {\n          input: Buffer.from([0, 0, 0, Math.round(255 * alpha)]),\n          raw: {\n            width: 1,\n            height: 1,\n            channels: 4,\n          },\n          tile: true,\n          blend: \"dest-in\",\n        },\n      ])\n      .toBuffer();\n\n    return Promise.all(\n      this.images.map((image) =>\n        Image.newSharp(image)\n          .composite([{ input, gravity, blend, tile, premultiplied }])\n          .toBuffer({ resolveWithObject: true }),\n      ),\n    );\n  }\n\n  /**\n   * @returns - converted images\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const image = new Image(image1, image2)\n   *  const buffers = await image.convert(\"webp\")\n   *  // => { data: Buffer; info: sharp.OutputInfo; }[]\n   * ```\n   * */\n  async convert<F extends ImageFormats>(format: F, options?: ImageOptions<F>) {\n    return Promise.all(\n      this.images.map((image) =>\n        Image.newSharp(image).toFormat(format, options).toBuffer({\n          resolveWithObject: true,\n        }),\n      ),\n    );\n  }\n\n  /**\n   * @returns - base on the callback return type\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const image = new Image(image1, image2)\n   *\n   *  await image.custom(\\* async *\\(sharp, _index) => {\n   *    return sharp.resize({ width: 1280, height: 720, fit: \"fill\" }).blur().toBuffer()\n   *  })\n   *  // => Buffer[]\n   *\n   *  await image.custom(\\* async *\\(_sharp, index) => {\n   *    return index\n   *  })\n   *  // => number[]\n   * ```\n   * */\n  async custom<T>(callback: ImageCustomCallback<T>): Promise<Awaited<T>[]> {\n    return Promise.all(this.images.map(async (image, index) => callback(Image.newSharp(image), index)));\n  }\n\n  /**\n   *\n   * @returns - filter non image\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const buffer = await Image.filter(image1, image2)\n   *  // => Buffer[]\n   * ```\n   */\n  static async filter(...images: Buffer[]) {\n    return new FilterFile(...images).image();\n  }\n\n  /**\n   *\n   * @returns - Extract buffer from return methods\n   *\n   * @example\n   * ```js\n   *  const image1 = await Image.loadFile(\"image1.png\")\n   *  const image2 = await Image.loadFile(\"image2.png\")\n   *\n   *  const image = new Image(image1, image2)\n   *  const converted = await image.convert(\"webp\")\n   *  // => { data: Buffer; info: sharp.OutputInfo; }[]\n   *\n   *  const buffers = Image.justBuffer(converted)\n   *  // => Buffer[]\n   * ```\n   * */\n  static justBuffer(rtn: { data: Buffer; info: sharp.OutputInfo }): Buffer;\n  static justBuffer(\n    rtn: {\n      data: Buffer;\n      info: sharp.OutputInfo;\n    }[],\n  ): Buffer[];\n  static justBuffer(\n    rtn:\n      | {\n          data: Buffer;\n          info: sharp.OutputInfo;\n        }[]\n      | {\n          data: Buffer;\n          info: sharp.OutputInfo;\n        },\n  ) {\n    if (Array.isArray(rtn)) return rtn.map((r) => Image.justBuffer(r));\n    return rtn.data;\n  }\n\n  /**\n   *\n   * @returns - Take screenshot of websites\n   *\n   * @example\n   * ```js\n   *  const image = awaitImage.screenshot(\"https://example.com\")\n   *  // Buffer\n   *\n   *  const images = awaitImage.screenshot([\"https://example.com\", \"https://example.net\"])\n   *  // Buffer[]\n   * ```\n   * */\n  static async screenshot<T extends string>(urls: T, options?: Omit<ScreenshotOptions, \"encoding\">): Promise<Buffer>;\n  static async screenshot<T extends string[]>(\n    urls: T,\n    options?: Omit<ScreenshotOptions, \"encoding\">,\n  ): Promise<Buffer[]>;\n  static async screenshot<T extends string | string[]>(urls: T, options?: ScreenshotOptions) {\n    if (Array.isArray(urls)) return Promise.all(urls.map(async (url) => Image.screenshot(url, options)));\n\n    const browser = await Core.initBrowser();\n    const page = await browser.newPage();\n\n    const res = await page.goto(urls, { waitUntil: \"networkidle2\" });\n    if (res === null || !res.ok()) throw new Error(`${Image.name}: Can't fetch (${urls})`);\n\n    const buffer = await page.screenshot(options);\n    await browser.close();\n    return buffer;\n  }\n\n  /**\n   * @throws\n   *\n   * load images from files\n   * @returns - loaded files\n   *\n   * @example\n   * ```js\n   *  const image = await Image.fromFile(\"image.png\")\n   *  // => Image\n   *\n   *  const image = await Image.fromFile(\"image.png\", \"text.txt\")\n   *  // => Image\n   *  const length = image.length\n   *  // => 1\n   *\n   *  const text = await Image.fromFile(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromFile(...path: string[]) {\n    const buffer = await Core.loadFile(path);\n    return Image.new(buffer);\n  }\n\n  /**\n   * @throws\n   *\n   * load images from urls\n   * @returns - loaded urls\n   *\n   * @example\n   * ```js\n   *  const image = await Image.fromUrl(\"image.png\")\n   *  // => Image\n   *\n   *  const image = await Image.fromUrl(\"image.png\", \"text.txt\")\n   *  // => Image\n   *  const length = image.length\n   *  // => 1\n   *\n   *  const text = await Image.fromUrl(\"text.txt\")\n   *  // => Error (throw)\n   * ```\n   */\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await Core.loadUrl(url);\n    return Image.new(buffer);\n  }\n\n  /**\n   * @returns - new instance of sharp\n   *\n   * @example\n   * ```js\n   *  const sharp = Image.newSharp(\"image.png\")\n   *  // => Sharp\n   * ```\n   */\n  static newSharp<T extends Buffer | string | undefined = undefined>(image?: T, options?: sharp.SharpOptions) {\n    return sharp(image, options).clone();\n  }\n\n  /**\n   * @throws\n   *\n   * @param images - images buffer\n   * @returns - create new safe instance\n   *\n   * @example\n   * ```js\n   *  const image = await Image.new(Buffer.alloc(1))\n   *  // => Error (throw)\n   *\n   *  const imageFile = await Image.loadFile(\"image.png\")\n   *\n   *  // filter non image\n   *  const image = await Image.new(imageFile, Buffer.alloc(1))\n   *  // => Image\n   *  const length = image.length\n   *  // => 1\n   * ```\n   */\n  static async new(images: Buffer[]) {\n    const filtered = await Image.filter(...images);\n    if (filtered.length === 0) throw new Error(`${Image.name}: Non valid image`);\n    return new Image(...filtered);\n  }\n}\n", "import type { Readable } from \"node:stream\";\nimport type {\n  BrotliCompressOptions,\n  BrotliDecompressOptions,\n  DeflateOptions,\n  DeflateRawOptions,\n  GunzipOptions,\n  GzipOptions,\n  InflateOptions,\n  InflateRawOptions,\n  TextCompressFn,\n  TextCompressionMethods,\n  TextCompressionOptions,\n  TextCustomCallback,\n  TextDecompressFn,\n  TextDecompressionMethods,\n  TextDecompressionOptions,\n  TextSetCallback,\n  UnzipOptions,\n} from \"../types/index.js\";\nimport zlib from \"node:zlib\";\nimport { FilterFile } from \"../helper/index.js\";\nimport Core from \"./core.js\";\n\n/**\n * At the end all files are just texts, so this class is applicable on all files\n */\nexport default class Text extends Core {\n  private texts: Buffer[];\n\n  constructor(...texts: Buffer[]) {\n    super();\n    this.texts = texts;\n  }\n\n  get length() {\n    return this.texts.length;\n  }\n\n  getTexts() {\n    return [...this.texts];\n  }\n\n  async setTexts<T>(callback: TextSetCallback<T>) {\n    const texts = await Promise.all(this.texts.map(async (text, index) => callback(text, index)));\n    const filteredTexts = texts.filter((text) => Buffer.isBuffer(text) && text.length > 0) as Buffer[];\n    this.texts = filteredTexts;\n    return this.length;\n  }\n\n  override async append(...texts: Buffer[]) {\n    // const filteredTexts = await Text.filter(...texts);\n    const filteredTexts = texts.filter((text) => Buffer.isBuffer(text) && text.length > 0) as Buffer[];\n    this.texts.push(...filteredTexts);\n    return this.length;\n  }\n\n  override extend(...texts: Text[]) {\n    texts.forEach((text) => {\n      this.texts.push(...text.getTexts());\n    });\n    return this.length;\n  }\n\n  override clone() {\n    return new Text(...this.texts);\n  }\n\n  override async filter() {\n    this.texts = await Text.filter(...this.texts);\n    return this.length;\n  }\n\n  /**\n   * @returns - key is the character code and value is the count\n   */\n  private charactersMap(text: Buffer) {\n    const map = new Map<number, number>();\n    const string = text.toString();\n\n    for (const str of string) {\n      const code = str.charCodeAt(0);\n      map.has(code) ? map.set(code, map.get(code)! + 1) : map.set(code, 1);\n    }\n\n    return map;\n  }\n\n  override async metadata() {\n    return Promise.all(\n      this.texts.map(async (text) => ({\n        size: text.length,\n        charactersMap: this.charactersMap(text),\n      })),\n    );\n  }\n\n  async compressAsync<T extends TextCompressionMethods>(method: T, options?: TextCompressionOptions<T>) {\n    return Promise.all(\n      Text.compress(\n        this.texts,\n        method,\n        Text.gzipAsync,\n        Text.deflateAsync,\n        Text.deflateRawAsync,\n        Text.brotliCompressAsync,\n        options,\n      ),\n    );\n  }\n\n  async decompressAsync<T extends TextDecompressionMethods>(method: T, options?: TextDecompressionOptions<T>) {\n    return Promise.all(\n      Text.decompress(\n        this.texts,\n        method,\n        Text.gunzipAsync,\n        Text.inflateAsync,\n        Text.inflateRawAsync,\n        Text.brotliDecompressAsync,\n        Text.unzipAsync,\n        options,\n      ),\n    );\n  }\n\n  async compressStream<T extends TextCompressionMethods>(method: T, options?: TextCompressionOptions<T>) {\n    const reads = await Core.toReadable(this.texts);\n    return Text.compress(\n      reads,\n      method,\n      Text.gzipStream,\n      Text.deflateStream,\n      Text.deflateRawStream,\n      Text.brotliCompressStream,\n      options,\n    );\n  }\n\n  async decompressStream<T extends TextDecompressionMethods>(method: T, options?: TextDecompressionOptions<T>) {\n    const reads = await Core.toReadable(this.texts);\n    return Text.decompress(\n      reads,\n      method,\n      Text.gunzipStream,\n      Text.inflateStream,\n      Text.inflateRawStream,\n      Text.brotliDecompressStream,\n      Text.unzipStream,\n      options,\n    );\n  }\n\n  compressSync<T extends TextCompressionMethods>(method: T, options?: TextCompressionOptions<T>) {\n    return Text.compress(\n      this.texts,\n      method,\n      Text.gzipSync,\n      Text.deflateSync,\n      Text.deflateRawSync,\n      Text.brotliCompressSync,\n      options,\n    );\n  }\n\n  decompressSync<T extends TextDecompressionMethods>(method: T, options?: TextDecompressionOptions<T>) {\n    return Text.decompress(\n      this.texts,\n      method,\n      Text.gunzipSync,\n      Text.inflateSync,\n      Text.inflateRawSync,\n      Text.brotliDecompressSync,\n      Text.unzipSync,\n      options,\n    );\n  }\n\n  async custom<T>(callback: TextCustomCallback<T>): Promise<Awaited<T>[]> {\n    return Promise.all(this.texts.map(async (text, index) => callback(text, index)));\n  }\n\n  static compress<R, T extends Buffer[] | Readable[], M extends TextCompressionMethods>(\n    array: T,\n    method: M,\n    gzipFn: TextCompressFn<R, T[number], M>,\n    deflateFn: TextCompressFn<R, T[number], M>,\n    deflateRawFn: TextCompressFn<R, T[number], M>,\n    brotliCompressFn: TextCompressFn<R, T[number], M>,\n    options?: TextCompressionOptions<M>,\n  ): R[] {\n    return array.map((text) => {\n      switch (method) {\n        case \"gzip\":\n          return gzipFn(text, options);\n        case \"deflate\":\n          return deflateFn(text, options);\n        case \"deflate-raw\":\n          return deflateRawFn(text, options);\n        case \"brotli-compress\":\n          return brotliCompressFn(text, options);\n        default:\n          throw new TypeError(`${Text.name}: Invalid compression method (${method})`);\n      }\n    });\n  }\n\n  static decompress<R, T extends Buffer[] | Readable[], M extends TextDecompressionMethods>(\n    array: T,\n    method: M,\n    gunzipFn: TextDecompressFn<R, T[number], M>,\n    inflateFn: TextDecompressFn<R, T[number], M>,\n    inflateRawFn: TextDecompressFn<R, T[number], M>,\n    brotliDecompressFn: TextDecompressFn<R, T[number], M>,\n    unzipFn: TextDecompressFn<R, T[number], M>,\n    options?: TextDecompressionOptions<M>,\n  ): R[] {\n    return array.map((text) => {\n      switch (method) {\n        case \"gunzip\":\n          return gunzipFn(text, options);\n        case \"inflate\":\n          return inflateFn(text, options);\n        case \"inflate-raw\":\n          return inflateRawFn(text, options);\n        case \"brotli-decompress\":\n          return brotliDecompressFn(text, options);\n        case \"unzip\":\n          return unzipFn(text, options);\n        default:\n          throw new TypeError(`${Text.name}: Invalid decompression method (${method})`);\n      }\n    });\n  }\n\n  static async filter(...texts: Buffer[]) {\n    return new FilterFile(...texts).text();\n  }\n\n  static async fromFile(...path: string[]) {\n    const buffer = await Core.loadFile(path);\n    return Text.new(buffer);\n  }\n\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await Core.loadUrl(url);\n    return Text.new(buffer);\n  }\n\n  static new(texts: Buffer[]) {\n    const filtered = texts.filter((text) => text.length > 0);\n    if (filtered.length === 0) throw new Error(`${Text.name}: Non valid text`);\n    return new Text(...filtered);\n  }\n\n  // Async Compression //\n\n  static async gzipAsync(text: Buffer, options: GzipOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.gzip(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async deflateAsync(text: Buffer, options: DeflateOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.deflate(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async deflateRawAsync(text: Buffer, options: DeflateRawOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.deflateRaw(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async brotliCompressAsync(text: Buffer, options: BrotliCompressOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.brotliCompress(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  // Async decompression //\n\n  static async gunzipAsync(text: Buffer, options: GunzipOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.gunzip(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async inflateAsync(text: Buffer, options: InflateOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.inflate(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async inflateRawAsync(text: Buffer, options: InflateRawOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.inflateRaw(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async brotliDecompressAsync(text: Buffer, options: BrotliDecompressOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.brotliDecompress(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  static async unzipAsync(text: Buffer, options: UnzipOptions = {}) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.unzip(text, options, (err, buf) => {\n        if (err) return reject(err);\n        resolve(buf);\n      });\n    });\n  }\n\n  // Stream compression //\n\n  static gzipStream(readable: Readable, options: GzipOptions = {}) {\n    const gzip = zlib.createGzip(options);\n    return Core.stream(readable, gzip);\n  }\n\n  static deflateStream(readable: Readable, options: DeflateOptions = {}) {\n    const deflate = zlib.createDeflate(options);\n    return Core.stream(readable, deflate);\n  }\n\n  static deflateRawStream(readable: Readable, options: DeflateRawOptions = {}) {\n    const deflateRaw = zlib.createDeflateRaw(options);\n    return Core.stream(readable, deflateRaw);\n  }\n\n  static brotliCompressStream(readable: Readable, options: BrotliCompressOptions = {}) {\n    const brotliCompress = zlib.createBrotliCompress(options);\n    return Core.stream(readable, brotliCompress);\n  }\n\n  // Stream decompression //\n\n  static gunzipStream(readable: Readable, options: GunzipOptions = {}) {\n    const gunzip = zlib.createGunzip(options);\n    return Core.stream(readable, gunzip);\n  }\n\n  static inflateStream(readable: Readable, options: InflateOptions = {}) {\n    const inflate = zlib.createInflate(options);\n    return Core.stream(readable, inflate);\n  }\n\n  static inflateRawStream(readable: Readable, options: InflateRawOptions = {}) {\n    const inflateRaw = zlib.createInflateRaw(options);\n    return Core.stream(readable, inflateRaw);\n  }\n\n  static brotliDecompressStream(readable: Readable, options: BrotliDecompressOptions = {}) {\n    const brotliDecompress = zlib.createBrotliDecompress(options);\n    return Core.stream(readable, brotliDecompress);\n  }\n\n  static unzipStream(readable: Readable, options: UnzipOptions = {}) {\n    const unzip = zlib.createUnzip(options);\n    return Core.stream(readable, unzip);\n  }\n\n  // Sync compression //\n\n  static gzipSync(buffer: Buffer, options: GzipOptions = {}) {\n    return zlib.gzipSync(buffer, options);\n  }\n\n  static deflateSync(buffer: Buffer, options: DeflateOptions = {}) {\n    return zlib.deflateSync(buffer, options);\n  }\n\n  static deflateRawSync(buffer: Buffer, options: DeflateRawOptions = {}) {\n    return zlib.deflateRawSync(buffer, options);\n  }\n\n  static brotliCompressSync(buffer: Buffer, options: BrotliCompressOptions = {}) {\n    return zlib.brotliCompressSync(buffer, options);\n  }\n\n  // Sync decompression //\n\n  static gunzipSync(buffer: Buffer, options: GunzipOptions = {}) {\n    return zlib.gunzipSync(buffer, options);\n  }\n\n  static inflateSync(buffer: Buffer, options: InflateOptions = {}) {\n    return zlib.inflateSync(buffer, options);\n  }\n\n  static inflateRawSync(buffer: Buffer, options: InflateRawOptions = {}) {\n    return zlib.inflateRawSync(buffer, options);\n  }\n\n  static brotliDecompressSync(buffer: Buffer, options: BrotliDecompressOptions = {}) {\n    return zlib.brotliDecompressSync(buffer, options);\n  }\n\n  static unzipSync(buffer: Buffer, options: UnzipOptions = {}) {\n    return zlib.unzipSync(buffer, options);\n  }\n}\n", "import type { PDFOptions } from \"puppeteer\";\nimport type { CreateOptions, LoadOptions, PDFImage, SaveOptions } from \"pdf-lib\";\nimport type {\n  PdfCustomDocumentCallback,\n  PDFFromImageOptions,\n  PDFMergeOptions,\n  PDFSetCallback,\n} from \"../types/index.js\";\nimport { PageSizes, PDFDocument } from \"pdf-lib\";\nimport { FilterFile } from \"../helper/index.js\";\nimport Core from \"./core.js\";\n\nexport default class PDF extends Core {\n  private pdfs: Buffer[];\n\n  constructor(...pdfs: Buffer[]) {\n    super();\n    this.pdfs = pdfs;\n  }\n\n  get length() {\n    return this.pdfs.length;\n  }\n\n  getPdfs() {\n    return [...this.pdfs];\n  }\n\n  async setPdfs<T>(callback: PDFSetCallback<T>) {\n    const pdfs = await Promise.all(this.pdfs.map(async (pdf, index) => callback(pdf, index)));\n    const filteredPdfs = pdfs.filter((pdf) => Buffer.isBuffer(pdf) && pdf.length > 0) as Buffer[];\n    const validPdfs = await PDF.filter(...filteredPdfs);\n    this.pdfs = validPdfs;\n    return this.length;\n  }\n\n  override async append(...pdfs: Buffer[]) {\n    const filteredPdfs = await PDF.filter(...pdfs);\n    this.pdfs.push(...filteredPdfs);\n    return this.length;\n  }\n\n  override extend(...pdfs: PDF[]) {\n    pdfs.forEach((pdf) => {\n      this.pdfs.push(...pdf.getPdfs());\n    });\n    return this.length;\n  }\n\n  override clone() {\n    return new PDF(...this.pdfs);\n  }\n\n  override async filter() {\n    this.pdfs = await PDF.filter(...this.pdfs);\n    return this.length;\n  }\n\n  async getDocuments(options?: LoadOptions) {\n    return Promise.all(this.pdfs.map((pdf) => PDF.load(pdf.buffer, options)));\n  }\n\n  override async metadata(options?: LoadOptions) {\n    const documents = await this.getDocuments(options);\n    return Promise.all(\n      documents.map(async (document) => ({\n        title: document.getTitle(),\n        author: document.getAuthor(),\n        subject: document.getSubject(),\n        creator: document.getCreator(),\n        keywords: document.getKeywords(),\n        producer: document.getProducer(),\n        pageCount: document.getPageCount(),\n        pageIndices: document.getPageIndices(),\n        creationDate: document.getCreationDate(),\n        modificationDate: document.getModificationDate(),\n      })),\n    );\n  }\n\n  async getPages(options?: LoadOptions) {\n    const documents = await this.getDocuments(options);\n    return Promise.all(documents.map(async (document) => document.getPages()));\n  }\n\n  async getForm(options?: LoadOptions) {\n    const documents = await this.getDocuments(options);\n    return Promise.all(documents.map(async (document) => document.getForm()));\n  }\n\n  async merge(options?: PDFMergeOptions) {\n    const merge = await PDF.create(options?.create);\n\n    const copies = await Promise.all(\n      this.pdfs.map(async (pdf) => {\n        const p = await PDF.load(pdf.buffer, options?.load);\n        return merge.copyPages(p, p.getPageIndices());\n      }),\n    );\n\n    copies.forEach((copied) => copied.forEach((page) => merge.addPage(page)));\n    return merge;\n  }\n\n  async custom<T>(callback: PdfCustomDocumentCallback<T>, options?: LoadOptions): Promise<Awaited<T>[]> {\n    const documents = await this.getDocuments(options);\n    return Promise.all(documents.map(async (document, index) => callback(document, index)));\n  }\n\n  static async fromFile(...path: string[]) {\n    const buffer = await Core.loadFile(path);\n    return PDF.new(buffer);\n  }\n\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await Core.loadUrl(url);\n    return PDF.new(buffer);\n  }\n\n  /**\n   * Convert image to pdf\n   * @param images - must be of format png or jpg\n   */\n  static async fromImage<T extends Buffer>(images: T, options?: PDFFromImageOptions): Promise<PDFDocument>;\n  static async fromImage<T extends Buffer[]>(images: T, options?: PDFFromImageOptions): Promise<PDFDocument[]>;\n  static async fromImage<T extends Buffer | Buffer[]>(images: T, options: PDFFromImageOptions = {}) {\n    if (Array.isArray(images)) return Promise.all(images.map((image) => PDF.fromImage(image, options)));\n\n    const [isPNG, isJPG] = await Promise.all([\n      new FilterFile(images).custom(\"png\"),\n      new FilterFile(images).custom(\"jpg\"),\n    ]);\n    if (isJPG.length === 0 && isPNG.length === 0) throw new Error(`${PDF.name}: Invalid images to convert to pdf`);\n\n    const { pageSize = PageSizes.A4, scaleImage, position } = options;\n\n    const pdf = await PDFDocument.create(options.create);\n    const page = pdf.addPage(pageSize);\n    const pageDimensions = page.getSize();\n\n    let pdfImage: PDFImage;\n    if (isPNG.length > 0) {\n      pdfImage = await pdf.embedPng(images.buffer);\n    } else {\n      pdfImage = await pdf.embedJpg(images.buffer);\n    }\n\n    let imageDimensions = pdfImage.size();\n    if (typeof scaleImage === \"number\") {\n      imageDimensions = pdfImage.scale(scaleImage);\n    } else if (Array.isArray(scaleImage)) {\n      imageDimensions = pdfImage.scaleToFit(scaleImage[0], scaleImage[1]);\n    } else {\n      imageDimensions = pdfImage.scaleToFit(pageDimensions.width, pageDimensions.height);\n    }\n\n    page.drawImage(pdfImage, {\n      x: position?.[0] ?? 0,\n      y: position?.[1] ?? 0,\n      width: imageDimensions.width,\n      height: imageDimensions.height,\n    });\n\n    return pdf;\n  }\n\n  /**\n   * Generate pdf from websites\n   */\n  static async generate<T extends string>(htmls: T, options?: PDFOptions): Promise<Buffer>;\n  static async generate<T extends string[]>(htmls: T, options?: PDFOptions): Promise<Buffer[]>;\n  static async generate<T extends string | string[]>(htmls: T, options?: PDFOptions) {\n    if (Array.isArray(htmls)) return Promise.all(htmls.map((html) => PDF.generate(html, options)));\n\n    const browser = await Core.initBrowser();\n    const page = await browser.newPage();\n\n    const res = await page.goto(htmls, { waitUntil: \"networkidle2\" });\n    if (res === null || !res.ok()) throw new Error(`${PDF.name}: Can't fetch (${htmls})`);\n\n    const buffer = await page.pdf(options);\n    await browser.close();\n    return buffer;\n  }\n\n  static filter(...pdfs: Buffer[]) {\n    return new FilterFile(...pdfs).custom(\"pdf\");\n  }\n\n  static async save<T extends PDFDocument>(pdfs: T, options?: SaveOptions): Promise<Uint8Array>;\n  static async save<T extends PDFDocument[]>(pdfs: T, options?: SaveOptions): Promise<Uint8Array[]>;\n  static async save<T extends PDFDocument | PDFDocument[]>(pdfs: T, options?: SaveOptions) {\n    if (!Array.isArray(pdfs)) return pdfs.save(options);\n    return Promise.all(pdfs.map((pdf) => PDF.save(pdf, options)));\n  }\n\n  static async load<T extends string | Uint8Array | ArrayBuffer>(pdf: T, options?: LoadOptions) {\n    return PDFDocument.load(pdf, options);\n  }\n\n  static async create(options?: CreateOptions) {\n    return PDFDocument.create(options);\n  }\n\n  static document() {\n    return PDFDocument;\n  }\n\n  static async new(pdfs: Buffer[]) {\n    const filtered = await PDF.filter(...pdfs);\n    if (filtered.length === 0) throw new Error(`${PDF.name}: Non valid pdf`);\n    return new PDF(...filtered);\n  }\n}\n", "import type { Readable } from \"node:stream\";\nimport type {\n  CSVCustomCallback,\n  CSVSetCallback,\n  GenerateOptions,\n  ParseOptions,\n  StringifyInput,\n  StringifyOptions,\n  TransformHandler,\n  TransformOptions,\n  TransformSyncHandler,\n} from \"../types/index.js\";\nimport * as csv from \"csv\";\nimport * as csvSync from \"csv/sync\";\nimport { FilterFile } from \"../helper/index.js\";\nimport Core from \"./core.js\";\n\nexport default class CSV extends Core {\n  private csvs: Buffer[];\n  constructor(...csvs: Buffer[]) {\n    super();\n    this.csvs = csvs;\n  }\n\n  get length() {\n    return this.csvs.length;\n  }\n\n  getCsvs() {\n    return [...this.csvs];\n  }\n\n  async setCsvs<T>(callback: CSVSetCallback<T>) {\n    const csvs = await Promise.all(this.csvs.map(async (csv, index) => callback(csv, index)));\n    const filteredCsvs = csvs.filter((csv) => Buffer.isBuffer(csv) && csv.length > 0) as Buffer[];\n    this.csvs = filteredCsvs;\n    return this.length;\n  }\n\n  override async append(...csvs: Buffer[]) {\n    // const filteredCsvs = await CSV.filter(...csvs);\n    const filteredCsvs = csvs.filter((csv) => Buffer.isBuffer(csv) && csv.length > 0) as Buffer[];\n    this.csvs.push(...filteredCsvs);\n    return this.length;\n  }\n\n  override extend(...csvs: CSV[]) {\n    csvs.forEach((csv) => {\n      this.csvs.push(...csv.getCsvs());\n    });\n    return this.length;\n  }\n\n  override clone() {\n    return new CSV(...this.csvs);\n  }\n\n  override async filter() {\n    this.csvs = await CSV.filter(...this.csvs);\n    return this.length;\n  }\n\n  override async metadata() {\n    return Promise.all(\n      this.csvs.map(async (csv) => {\n        const parse = await CSV.parseAsync(csv);\n        return {\n          size: csv.length,\n          rows: parse.length,\n          columns: parse?.[0]?.length ?? 0,\n        };\n      }),\n    );\n  }\n\n  // Async //\n\n  async parseAsync<P = any>(options?: ParseOptions) {\n    return Promise.all(this.csvs.map((c) => CSV.parseAsync<Buffer, P>(c, options)));\n  }\n\n  async transformAsync<T, U, P = any>(parsed: any[], handler: TransformHandler<T, U>, options?: TransformOptions) {\n    return Promise.all(parsed.map((p) => CSV.transformAsync<T, U, P>(p, handler, options)));\n  }\n\n  async stringifyAsync(csvs: StringifyInput, options?: StringifyOptions) {\n    return Promise.all(csvs.map((c) => CSV.stringifyAsync(c, options)));\n  }\n\n  // Stream //\n\n  async parseStream(options?: ParseOptions) {\n    const reads = await Core.toReadable(this.csvs);\n    return reads.map((csv) => CSV.parseStream(csv, options));\n  }\n\n  async transformStream<T, U>(parsed: any[], handler: TransformHandler<T, U>, options?: TransformOptions) {\n    const reads = await Core.toReadable(parsed);\n    return reads.map((csv) => CSV.transformStream(csv, handler, options));\n  }\n\n  async stringifyStream(csvs: StringifyInput, options?: StringifyOptions) {\n    const reads = await Core.toReadable(csvs);\n    return reads.map((csv) => CSV.stringifyStream(csv, options));\n  }\n\n  // Sync //\n\n  parseSync(options?: ParseOptions) {\n    return this.csvs.map((c) => CSV.parseSync(c, options));\n  }\n\n  transformSync<T, U>(parsed: any[], handler: TransformSyncHandler<T, U>, options?: TransformOptions) {\n    return parsed.map((p) => CSV.transformSync(p, handler, options));\n  }\n\n  stringifySync(csvs: StringifyInput, options?: StringifyOptions) {\n    return csvs.map((c) => CSV.stringifySync(c, options));\n  }\n\n  // parseStream(options?: ParseOptions): Stream[] {\n  //   return this.csvs.map((csv) => CSV.parseStream(csv, options));\n  // }\n\n  // transformStream<T, U>(\n  //   handler: TransformHandler<T, U>,\n  //   options?: TransformOptions\n  // ): Stream[] {\n  //   return this.csvs.map((c) => {\n  //     return csv.parse(c).pipe(csv.transform(options, handler));\n  //   });\n  // }\n\n  async custom<T>(callback: CSVCustomCallback<T>): Promise<Awaited<T>[]> {\n    return Promise.all(this.csvs.map(async (csv, index) => callback(csv, index)));\n  }\n\n  static async filter(...csvs: Buffer[]) {\n    return new FilterFile(...csvs).custom(\"csv\");\n  }\n\n  static async fromFile(...path: string[]) {\n    const buffer = await Core.loadFile(path);\n    return CSV.new(buffer);\n  }\n\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await Core.loadUrl(url);\n    return CSV.new(buffer);\n  }\n\n  static new(csvs: Buffer[]) {\n    const filtered = csvs.filter((csv) => csv.length > 0);\n    if (filtered.length === 0) throw new Error(`${CSV.name}: Non valid csv`);\n    return new CSV(...filtered);\n  }\n\n  // Async //\n\n  static async generateAsync<P = any>(options: GenerateOptions = {}) {\n    return new Promise<P>((resolve, reject) => {\n      csv.generate(options, (err, records) => {\n        if (err) return reject(err);\n        resolve(records);\n      });\n    });\n  }\n\n  static async parseAsync<T extends Buffer | string, P = any>(input: T, options: ParseOptions = {}) {\n    return new Promise<P>((resolve, reject) => {\n      csv.parse(input, options, (err, records) => {\n        if (err) return reject(err);\n        resolve(records);\n      });\n    });\n  }\n\n  static async transformAsync<T, U, P = any>(\n    records: T[],\n    handler: TransformHandler<T, U>,\n    options: TransformOptions = {},\n  ) {\n    return new Promise<P>((resolve, reject) => {\n      csv.transform(records, options, handler, (err, records) => {\n        if (err) return reject(err);\n        resolve(records as P);\n      });\n    });\n  }\n\n  static async stringifyAsync(input: StringifyInput, options: StringifyOptions = {}) {\n    return new Promise<string>((resolve, reject) => {\n      csv.stringify(input, options, (err, str) => {\n        if (err) return reject(err);\n        resolve(str);\n      });\n    });\n  }\n\n  // Stream //\n\n  static generateStream(options: GenerateOptions = {}) {\n    return csv.generate(options);\n  }\n\n  static parseStream(readable: Readable, options: ParseOptions = {}) {\n    return Core.stream(readable, csv.parse(options));\n  }\n\n  static transformStream<T, U>(readable: Readable, handler: TransformHandler<T, U>, options: TransformOptions = {}) {\n    return Core.stream(readable, csv.transform(options, handler));\n  }\n\n  static stringifyStream(readable: Readable, options: StringifyOptions = {}) {\n    return Core.stream(readable, csv.stringify(options));\n  }\n\n  // Sync //\n\n  static generateSync(options: GenerateOptions = {}) {\n    return csvSync.generate(options);\n  }\n\n  static parseSync<T extends Buffer | string>(input: T, options: ParseOptions = {}) {\n    return csvSync.parse(input, options);\n  }\n\n  static transformSync<T, U>(records: T[], handler: TransformSyncHandler<T, U>, options: TransformOptions = {}) {\n    return csvSync.transform(records, options, handler);\n  }\n\n  static stringifySync(input: StringifyInput, options: StringifyOptions = {}) {\n    return csvSync.stringify(input, options);\n  }\n}\n", "import type { AVCustomCallback } from \"../../types/index.js\";\nimport type { Readable } from \"node:stream\";\nimport ffmpeg, { type FfprobeData } from \"fluent-ffmpeg\";\nimport { path as ffmpegPath } from \"@ffmpeg-installer/ffmpeg\";\nimport { path as ffprobePath } from \"@ffprobe-installer/ffprobe\";\nimport path from \"node:path\";\nimport { TmpFile } from \"../../helper/index.js\";\nimport Core from \"../core.js\";\n\nexport default abstract class AV extends Core {\n  protected avs: Buffer[];\n\n  constructor(...avs: Buffer[]) {\n    super();\n    this.avs = avs;\n  }\n\n  get length() {\n    return this.avs.length;\n  }\n\n  override async metadata() {\n    const tmpFile = await new TmpFile(...this.avs).init();\n    const result = await Promise.all(\n      tmpFile.paths.map(\n        (av) =>\n          new Promise<FfprobeData>((resolve, reject) => {\n            AV.newFfmpeg(av).ffprobe((err, metadata) => {\n              if (err) return reject(err);\n              resolve(metadata);\n            });\n          }),\n      ),\n    );\n    await tmpFile.clean();\n    return result;\n  }\n\n  async convert(format: string, options?: ffmpeg.FfmpegCommandOptions) {\n    const tmpFile = await new TmpFile(...this.avs).init();\n\n    const result = await Promise.all(\n      tmpFile.paths.map((p) => {\n        return new Promise<Buffer>((resolve, reject) => {\n          const output = path.join(tmpFile.tmp!.path, TmpFile.generateFileName(format));\n          AV.newFfmpeg(p, options)\n            .on(\"end\", () => {\n              Core.loadFile(output).then(resolve, reject);\n            })\n            .on(\"error\", reject)\n            .output(output, { end: true })\n            .run();\n        });\n      }),\n    );\n\n    await tmpFile.clean();\n    return result;\n  }\n\n  // async stream() {\n  //   const reads = await Core.toReadable(this.avs);\n  //   return reads.map((av) => AV.newFfmpeg(av).pipe());\n  // }\n\n  /**\n   * In case of invalid method, buffer will be default\n   */\n  async custom<T>(callback: AVCustomCallback<T>): Promise<Awaited<T>[]> {\n    const tmpFile = await new TmpFile(...this.avs).init();\n    const result = await Promise.all(tmpFile.paths.map(async (path, index) => callback(AV.newFfmpeg(path), index)));\n    await tmpFile.clean();\n    return result;\n  }\n\n  /**\n   * new Instance of ffmpeg\n   */\n  static newFfmpeg<T extends Readable | string>(av: T, options?: ffmpeg.FfmpegCommandOptions) {\n    return ffmpeg(options).clone().setFfmpegPath(ffmpegPath).setFfprobePath(ffprobePath).input(av);\n  }\n}\n", "import type { AVSetCallback } from \"../../types/index.js\";\nimport { FilterFile } from \"../../helper/index.js\";\nimport Core from \"../core.js\";\nimport AV from \"./av.js\";\n\nexport default class Audio extends AV {\n  constructor(...audios: Buffer[]) {\n    super(...audios);\n  }\n\n  getAudios() {\n    return [...this.avs];\n  }\n\n  async setAudios<T>(callback: AVSetCallback<T>) {\n    const audios = await Promise.all(this.avs.map(async (audio, index) => callback(audio, index)));\n    const filteredAudios = audios.filter((audio) => Buffer.isBuffer(audio) && audio.length > 0) as Buffer[];\n    const validAudios = await Audio.filter(...filteredAudios);\n    this.avs = validAudios;\n    return this.length;\n  }\n\n  override async append(...audios: Buffer[]) {\n    const filteredAudios = await Audio.filter(...audios);\n    this.avs.push(...filteredAudios);\n    return this.length;\n  }\n\n  override extend(...audios: Audio[]) {\n    audios.forEach((audio) => {\n      this.avs.push(...audio.getAudios());\n    });\n    return this.length;\n  }\n\n  override clone() {\n    return new Audio(...this.avs);\n  }\n\n  override async filter() {\n    this.avs = await Audio.filter(...this.avs);\n    return this.length;\n  }\n\n  static filter(...audios: Buffer[]) {\n    return new FilterFile(...audios).audio();\n  }\n\n  static async fromFile(...path: string[]) {\n    const buffer = await Core.loadFile(path);\n    return Audio.new(buffer);\n  }\n\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await Core.loadUrl(url);\n    return Audio.new(buffer);\n  }\n\n  static async new(audios: Buffer[]) {\n    const filtered = await Audio.filter(...audios);\n    if (filtered.length === 0) throw new Error(`${Audio.name}: Non valid audio`);\n    return new Audio(...filtered);\n  }\n}\n", "import type { AVSetCallback } from \"../../types/index.js\";\nimport { FilterFile } from \"../../helper/index.js\";\nimport Core from \"../core.js\";\nimport AV from \"./av.js\";\n\nexport default class Video extends AV {\n  constructor(...videos: Buffer[]) {\n    super(...videos);\n  }\n\n  getVideos() {\n    return [...this.avs];\n  }\n\n  async setVideos<T>(callback: AVSetCallback<T>) {\n    const videos = await Promise.all(this.avs.map(async (video, index) => callback(video, index)));\n    const filteredVideos = videos.filter((video) => Buffer.isBuffer(video) && video.length > 0) as Buffer[];\n    const validVideos = await Video.filter(...filteredVideos);\n    this.avs = validVideos;\n    return this.length;\n  }\n\n  override async append(...videos: Buffer[]) {\n    const filteredVideos = await Video.filter(...videos);\n    this.avs.push(...filteredVideos);\n    return this.length;\n  }\n\n  override extend(...videos: Video[]) {\n    videos.forEach((video) => {\n      this.avs.push(...video.getVideos());\n    });\n    return this.length;\n  }\n\n  override clone() {\n    return new Video(...this.avs);\n  }\n\n  override async filter() {\n    this.avs = await Video.filter(...this.avs);\n    return this.length;\n  }\n\n  static async filter(...videos: Buffer[]) {\n    return new FilterFile(...videos).video();\n  }\n\n  static async fromFile(...path: string[]) {\n    const buffer = await Core.loadFile(path);\n    return Video.new(buffer);\n  }\n\n  static async fromUrl<T extends string[] | URL[]>(...url: T) {\n    const buffer = await Core.loadUrl(url);\n    return Video.new(buffer);\n  }\n\n  static async new(videos: Buffer[]) {\n    const filtered = await Video.filter(...videos);\n    if (filtered.length === 0) throw new Error(`${Video.name}: Non valid video`);\n    return new Video(...filtered);\n  }\n}\n", "import { Image, Text, PDF, CSV, Video, Audio } from \"./core/index.js\";\n\nexport default class Processor {\n  private readonly files: Buffer[];\n\n  constructor(...files: Buffer[]) {\n    this.files = files;\n  }\n\n  image() {\n    return Image.new(this.files);\n  }\n\n  pdf() {\n    return PDF.new(this.files);\n  }\n\n  csv() {\n    return CSV.new(this.files);\n  }\n\n  text() {\n    return Text.new(this.files);\n  }\n\n  video() {\n    return Video.new(this.files);\n  }\n\n  audio() {\n    return Audio.new(this.files);\n  }\n}\n"],
  "mappings": "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",
  "names": ["core_exports", "__export", "Audio", "CSV", "Image", "PDF", "Text", "Video", "helper_exports", "__export", "FilterFile", "TmpFile", "input2buffer", "isArrayOfBuffer", "isArrayOfString", "isUrl", "Mutex", "isFile", "Readable", "isAnyArrayBuffer", "isUint8Array", "readFile", "writeFile", "fsStat", "readdir", "path", "any2buffer", "array2buffer", "buffer2readable", "isReadable", "isReadableStream", "isStream", "readable2buffer", "readablestream2buffer", "stream2buffer", "string2buffer", "uint8array2buffer", "url2buffer", "isBase64", "fastGlob", "puppeteer", "Core", "_Core", "readable", "writable", "options", "puppeteer", "paths", "__async", "path", "readFile", "files", "readdir", "file", "globs", "_a", "entries", "fastGlob", "cwd", "entry", "fullPath", "stat", "fsStat", "result", "urls", "url", "url2buffer", "input", "i", "isUrl", "isUint8Array", "uint8array2buffer", "isAnyArrayBuffer", "array2buffer", "isStream", "stream2buffer", "isReadableStream", "readablestream2buffer", "isReadable", "Readable", "readable2buffer", "isBase64", "string2buffer", "any2buffer", "buffer", "buffer2readable", "encoding", "f", "writeFile", "FilterFile", "_FilterFile", "input", "__async", "applications", "audios", "fonts", "images", "models", "texts", "videos", "me", "buffer", "Core", "isFile", "file", "mutexes", "Mutex", "files", "release", "writeFile", "randomUUID", "path", "dir", "isFileNode", "TmpFile", "_TmpFile", "files", "file", "__async", "_a", "_b", "ext", "isFileNode", "fileName", "fullPath", "path", "writeFile", "options", "dir", "__spreadValues", "randomUUID", "readFile", "isReadable", "isStream", "stream2buffer", "isArrayBuffer", "isSharedArrayBuffer", "isUint8Array", "input2buffer", "input", "__async", "readFile", "isReadable", "isStream", "stream2buffer", "isUint8Array", "isArrayBuffer", "isSharedArrayBuffer", "isArrayOfBuffer", "array", "arr", "isArrayOfString", "isUrl", "value", "error", "sharp", "Image", "_Image", "Core", "images", "callback", "__async", "filteredImages", "image", "index", "validImages", "_0", "logo", "options", "resize", "gravity", "alpha", "tile", "blend", "premultiplied", "buffer", "input", "format", "FilterFile", "rtn", "r", "urls", "url", "browser", "page", "res", "path", "sharp", "filtered", "zlib", "Text", "_Text", "Core", "texts", "callback", "__async", "filteredTexts", "text", "index", "map", "string", "str", "code", "method", "options", "reads", "array", "gzipFn", "deflateFn", "deflateRawFn", "brotliCompressFn", "gunzipFn", "inflateFn", "inflateRawFn", "brotliDecompressFn", "unzipFn", "FilterFile", "path", "buffer", "url", "filtered", "_0", "resolve", "reject", "zlib", "err", "buf", "readable", "gzip", "deflate", "deflateRaw", "brotliCompress", "gunzip", "inflate", "inflateRaw", "brotliDecompress", "unzip", "PageSizes", "PDFDocument", "PDF", "_PDF", "Core", "pdfs", "callback", "__async", "filteredPdfs", "pdf", "index", "validPdfs", "options", "documents", "document", "merge", "p", "copied", "page", "path", "buffer", "url", "_0", "images", "_a", "_b", "image", "isPNG", "isJPG", "FilterFile", "pageSize", "PageSizes", "scaleImage", "position", "PDFDocument", "pageDimensions", "pdfImage", "imageDimensions", "htmls", "html", "browser", "res", "filtered", "csv", "csvSync", "CSV", "_CSV", "Core", "csvs", "callback", "__async", "filteredCsvs", "csv", "index", "_a", "_b", "parse", "options", "c", "parsed", "handler", "p", "FilterFile", "path", "buffer", "url", "filtered", "resolve", "reject", "err", "records", "_0", "input", "_1", "str", "readable", "ffmpeg", "ffmpegPath", "ffprobePath", "path", "AV", "_AV", "Core", "avs", "__async", "tmpFile", "TmpFile", "result", "av", "resolve", "reject", "err", "metadata", "format", "options", "p", "output", "path", "callback", "index", "ffmpeg", "ffmpegPath", "ffprobePath", "Audio", "_Audio", "AV", "audios", "callback", "__async", "filteredAudios", "audio", "index", "validAudios", "FilterFile", "path", "buffer", "Core", "url", "filtered", "Video", "_Video", "AV", "videos", "callback", "__async", "filteredVideos", "video", "index", "validVideos", "FilterFile", "path", "buffer", "Core", "url", "filtered", "Processor", "files", "Image", "PDF", "CSV", "Text", "Video", "Audio"]
}
